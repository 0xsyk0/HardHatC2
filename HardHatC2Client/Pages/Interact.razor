@page "/Interact"
@using ApiModels.Requests
@using ApiModels.Responses
@using HardHatC2Client.Components;
@using HardHatC2Client.Models
@using HardHatC2Client.Services
@using HardHatC2Client.Utilities
@using BlazorXTabs
@using MudBlazor
@using RestSharp
@using AutoMapper
@using System.Collections.Generic
@using System.Collections.Concurrent
@using System.Collections.ObjectModel
@using System.Linq
@using Blazored.Typeahead
@using System.Diagnostics;
@inject RestClient restClient
@inject NavigationManager navigationManagerDefault
@inject ISnackbar Snackbar
@inject IToastService toastService

<CascadingAuthenticationState>
<AuthorizeView Roles="Operator">
    <Authorized>
        
<h3 class="text-center">Interact</h3>
<div class="container-fluid">
</div>

 
<MudContainer Fixed="true">
<MudTabs Outlined="true">
    <MudTabPanel Text="Engineers" Icon="@Icons.Material.Filled.Build" >
        <XTabs Style="@setTabStyle(Settings.IsCheckedBox)" IsDraggable="true" NewTabSetActive="true" RenderMode="BlazorXTabs.Configuration.RenderMode.Full" CloseTabs="true">
    @foreach (Engineer engineer in InteractEngineers)
    {
        string tabTitle = EngTabTitleDic[engineer.Id];
        <XTab Title=@tabTitle>
            <MudCard Class="" Style=" background:#111111; overflow-y:auto" Outlined="true"> <!--This is the parent card  -->
                <MudCardContent Style="background:#111111; color:white; height:800px">
                    @if (EngineerOutboundTaskIds.ContainsKey(engineer.Id))
                    {
                        @foreach (string currenttask in EngineerOutboundTaskIds[engineer.Id])
                        {
                                string commandHeaderText = TaskOutputHeaderInfo[currenttask]; // gets the input based on the current task index so its always unique
                                <MudExpansionPanels Style="background:#32333d; color:white;" MultiExpansion="true">
                                <MudExpansionPanel IsExpandedChanged="(e)=>ExpandedChanged(e,engineer.Id,currenttask)"  style="background:#32333d; color:white;">
                                <TitleContent>
                                @if (PickedUpTasks.Contains(currenttask) && !(EngineerReturnedTaskIds.Values.Any(x => x.Contains(currenttask))))
                                {
                                    <div class="d-flex">
                                        <MudProgressCircular Size="Size.Small" Color="Color.Primary" Indeterminate="true" Class="mr-3" />
                                        <MudIconButton Icon="@Icons.Material.Filled.Cancel" Size="Size.Small" Color="Color.Error" OnClick="() =>CancelTask(currenttask,engineer.Id)"></MudIconButton>
                                        <MudText>@commandHeaderText</MudText>                                                   
                                    </div>
                                }
                                else if (EngineerReturnedTaskIds.Values.Any(x => x.Contains(currenttask) && TaskStatusDic.ContainsKey(currenttask)))
                                {
                                    if (TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Running)
                                    {
                                        <div class="d-flex">
                                            <MudProgressCircular Size="Size.Small" Color="Color.Primary" Indeterminate="true" Class="mr-3" />
                                            <MudIconButton Icon="@Icons.Material.Filled.Cancel" Size="Size.Small" Color="Color.Error" OnClick="() =>CancelTask(currenttask,engineer.Id)"></MudIconButton>
                                            <MudText>@commandHeaderText</MudText>

                                        </div>
                                    }
                                    else
                                    {
                                        <div class="d-flex">
                                            <MudIcon Icon=@setIcon(currenttask) Color=@SetColor(currenttask) class="mr-3"></MudIcon>
                                            <MudText>@commandHeaderText</MudText>
                                        </div>
                                    }
                                }
                                else
                                {
                                    <div class="d-flex">
                                        <MudIcon Icon=@setIcon(currenttask) Color=@SetColor(currenttask) class="mr-3"></MudIcon>
                                        <MudText>@commandHeaderText</MudText>
                                    </div>
                                }
                                
                                </TitleContent>
                                <ChildContent>
                                <MudCard Class="" Style="background:var(--background);" Outlined="true"> <!--This is the per input and output card-->
                                <MudCardContent Style="background:#111111; color:white; white-space:pre-wrap;">
                                
                                    @if (TaskOutputDic.ContainsKey(currenttask))
                                    {
                                        <!-- <MudText>output for components go here atm thats ls command, ps command, ipconfig, anything that can use a table</MudText> -->
                                        // List<string> output = TaskOutputDic[currenttask];
                                        string output = TaskOutputDic[currenttask];
                                        @if(output !=null)
                                        {
                                            @if (TaskInputDic[currenttask].Command =="ls")
                                            {
                                                <HardHatC2Client.Components.DirectoryListingTable Outputs="@output.Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList()" />
                                            }
                                            else if (TaskInputDic[currenttask].Command == "ps")
                                            {
                                                <HardHatC2Client.Components.ProcessListingTable Outputs="@output.Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList()" />
                                            }
                                            else if (TaskInputDic[currenttask].Command == "getprivs")
                                            {
                                                <HardHatC2Client.Components.GetPrivsTable Outputs="@output.Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList()" />
                                            }
                                            else if (TaskInputDic[currenttask].Command == "print-env")
                                            {
                                                <HardHatC2Client.Components.PrintEnvTable Outputs="@output.Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList()" />
                                            }
                                            else if (ParsedCommandOutputDic.ContainsKey(currenttask))
                                            {
                                                                <MudSwitch @bind-Checked="@IsTableView" Label="Toggle Table View" Color="Color.Success" />
                                                if(IsTableView == true)
                                                {
                                                    <HardHatC2Client.Components.AutpParsedCommandTable Outputs="ParsedCommandOutputDic[currenttask]"></HardHatC2Client.Components.AutpParsedCommandTable>
                                                }
                                                else
                                                {
                                                                    <MudText Class="text-break" style="font-family:Courier New, Courier, monospace">@output</MudText>
                                                    @*@foreach (string outputtext in output)
                                                    {
                                                        <MudText Class="text-break" style="font-family:Courier New, Courier, monospace">@outputtext</MudText>
                                                    }*@
                                                }
                                            }
                                            else
                                            {
                                                                <MudText Class="text-break" style="font-family:Courier New, Courier, monospace">@output</MudText>
                                                @*@foreach (string outputtext in output)
                                                {
                                                    <MudText Class="text-break" style="font-family:Courier New, Courier, monospace">@outputtext</MudText>
                                                }*@
                                            }
                                        }
                                    }
                                                   
                                    else if (!TaskOutputDic.ContainsKey(currenttask))
                                    {
                                        <MudText Typo="Typo.body2">No output yet</MudText>
                                    }
                                 
                                    
                               </MudCardContent>
                            </MudCard>  
                             </ChildContent>
                            </MudExpansionPanel><!--This is the end of per input and output card -->   
                            </MudExpansionPanels>
                        }
                    }
                </MudCardContent>
            </MudCard>
            <EditForm Context="EditFormContext" Model="engineer" OnValidSubmit="@Send">
            <div class="d-flex mb-xl-5">
                
                    <MudAutocomplete OnKeyUp="OnShowHistoryUp" @ref="mudauto" @bind-Value=@placeHolder T="string" ResetValueOnEmptyText="true" SearchFunc="@SearchCommand"
                                   Dense="true" Margin="Margin.Dense" SelectValueOnTab="true"  SelectOnClick="false" CoerceText="false" CoerceValue="true"
                                     InputMode="InputMode.text" Variant="Variant.Text" Adornment="Adornment.Start" AdornmentText="[ENGINEER]> " Immediate="true" Clearable="true" KeyDownPreventDefault="true" KeyUpPreventDefault="true" TextUpdateSuppression="@TextSuppersion">
                </MudAutocomplete>
                                 
                <MudButton style="background:var(--font-color);color:var(--background)" OnClick=@Send> <MudText>Send</MudText></MudButton>
                @if (IsEnterkey)
                {
                    Task.Run(async () => await SendTask(engineer, UserInput));
                    IsEnterkey = false;
                }
            </div>
            </EditForm>
            <MudSimpleTable Dense=true>
                <thead class ="table table-bordered border-dark" style="background:var(--font-color); color:var(--background);">
                <tr>
                    <th>Status</th>
                    <th>External Address</th>
                    <th>Manager</th>
                    <th>Connection Type</th>
                    <th>Address</th>
                    <th>hostname</th>
                    <th>username</th>
                    <th>process</th>
                    <th>pid</th>
                    <th>Integrity</th>
                    <th>arch</th>
                    <th>Sleep</th>
                    <th>lastseen</th>
                </tr>
                </thead>
                <tbody>
                <tr class="table" style="background:var(--background); color:var(--font-color);">
                    <td>@engineer.Status</td>
                    <td>@engineer.ExternalAddress</td>
                    <td>@engineer.ManagerName</td>
                    <td>@engineer.ConnectionType</td>
                    <td>@engineer.Address</td>
                    <td>@engineer.Hostname</td>
                    <td>@engineer.Username</td>
                    <td>@engineer.ProcessName</td>
                    <td>@engineer.ProcessId</td>
                    <td>@engineer.Integrity</td>
                    <td>@engineer.Arch</td>
                    <td>@engineer.Sleep</td>
                    <td>@Engineers.LastSeenTimer(engineer)</td>
                </tr>
                </tbody>
            </MudSimpleTable>
        </XTab>
    }
</XTabs>
    </MudTabPanel>
    <MudTabPanel Text="Browsers" Icon="@Icons.Material.Filled.FolderOpen">
                        <FileBrowser></FileBrowser>
    </MudTabPanel>
    <MudTabPanel Text="Terminal" Icon="@Icons.Material.Filled.Terminal" >
        <InteractiveTerminal></InteractiveTerminal>            
    </MudTabPanel>
</MudTabs>
</MudContainer>

    </Authorized>
    <NotAuthorized>
        <h1 class="text-center">Not Authorized</h1>
            <HardHatC2Client.Components.UnAuthorizedDialogBox></HardHatC2Client.Components.UnAuthorizedDialogBox>
    </NotAuthorized>
</AuthorizeView>
</CascadingAuthenticationState>

@code {
    [Inject] 
    private IDialogService DialogService { get; set; }
    [Inject]
    private static RestClient _restClient { get; set; }
    [Inject]
    private static NavigationManager Nav { get; set; }
    private static Dictionary<string,List<string>> EngineerOutboundTaskIds = new(); // key is engineer id, value is list of task ids
    private static Dictionary<string,EngineerTask> TaskInputDic = new(); // first key is taskId and value is the userInput for commands


    private static Dictionary<string,List<string>> EngineerReturnedTaskIds = new(); // key is engineer id, value is list of task ids
    private static Dictionary<string,string> TaskOutputDic = new(); // first key is taskID and value is the output from the task
    private static Dictionary<string, EngineerTaskResponse.EngTaskStatus> TaskStatusDic = new(); // first key is taskID and value is the status of the task

    private static Dictionary<string, string> TaskOutputHeaderInfo = new(); // first key is taskID and value is the task output header 
    public static List<Engineer> InteractEngineers = new(); // list of the engineerrs the user has added for interaction 

    public static Dictionary<string, string> EngTabTitleDic = new(); // key is engineer id, value is the tab title

    public static Dictionary<string, List<string>> ParsedCommandOutputDic = new(); // key is task id, value is a dictionary of properties containing the property name and value
    public static Dictionary<string, int> LinesParsedCommandsDic = new();

    public static List<string> PickedUpTasks = new();

    private static string UserInput { get; set;}
    private string placeHolder = null;
    private bool IsEnterkey { get; set; } = false;
    //private static Command userCommand = new Command();
    private MudAutocomplete<string> mudauto { get; set; }
    private Engineer currentEng = null;
    private static List<string> PreviousCommands = new();
    private string selectedHistoryCommand = null;
    private static int HistoryIndex = 1;

    private string icon = Icons.Material.Filled.CheckCircle;
    private static bool TextSuppersion = true;
    private static bool IsTableView = true;
    private static bool firstRender = true;
    private static bool Initialized = false;

    private static Stopwatch stopwatch = new Stopwatch();
    private static Stopwatch stopwatch2 = new Stopwatch();

    private static string OutputOneStringTest = "";
    //private static event  OnStateChangeRequested;

    private string setTabStyle(bool IsDark)
    {
        if(IsDark)
        {
            return "background:#32333d; color:white;";
        }
        return "background:white; color:black;";  
    }

    //set the icon and color for commands 
    private string setIcon(string currentTaskId)
    {
        if (TaskStatusDic.ContainsKey(currentTaskId))
        {
            if (TaskStatusDic[currentTaskId] == EngineerTaskResponse.EngTaskStatus.Complete)
            {
                return Icons.Filled.CheckCircle;
            }
            else if (TaskStatusDic[currentTaskId] == EngineerTaskResponse.EngTaskStatus.Cancelled)
            {
                return Icons.Filled.StopCircle;
            }
            else if (TaskStatusDic[currentTaskId] == EngineerTaskResponse.EngTaskStatus.Failed)
            {
                return Icons.Filled.SmsFailed;
            }
            else if (TaskStatusDic[currentTaskId] == EngineerTaskResponse.EngTaskStatus.FailedWithWarnings)
            {
                return Icons.Filled.Warning;
            }
            else
            {
                return Icons.Filled.Info;
            }
        }
        else
        {
            return Icons.Filled.Info;
        }
    }

    private Color SetColor(string currentTaskId)
    {
        if (TaskStatusDic.ContainsKey(currentTaskId))
        {
            if (TaskStatusDic[currentTaskId] == EngineerTaskResponse.EngTaskStatus.Complete)
            {
                return Color.Success;
            }
            else if (TaskStatusDic[currentTaskId] == EngineerTaskResponse.EngTaskStatus.Cancelled)
            {
                return Color.Secondary;
            }
            else if (TaskStatusDic[currentTaskId] == EngineerTaskResponse.EngTaskStatus.Failed)
            {
                return Color.Error;
            }
            else if (TaskStatusDic[currentTaskId] == EngineerTaskResponse.EngTaskStatus.FailedWithWarnings)
            {
                return Color.Warning;
            }
            else
            {
                return Color.Info;
            }
        }
        else
        {
            return Color.Info;
        }
    }

    public static async Task AddTaskToPickedUpList(string taskid)
    {
        if (!PickedUpTasks.Contains(taskid))
        {
            PickedUpTasks.Add(taskid);
        }
    }

    private async Task<IEnumerable<string>> SearchCommand(string value)
    {
        //if input is blank or null give the whole list. 
        if (string.IsNullOrEmpty(value))
        {
            var list = Help.menuItems.Select(x => x.Usage);
            //alpabatize the list by the Name before returning it 
            return list.OrderBy(x => x);
        }
        //return the name of the Help.MenuItem that matches the search term
        var resultItem = await Task.FromResult(Help.menuItems.Where(x => x.Name.ToLower().Contains(value.ToLower())).ToList());
        //alphabetize and return the list
        var nameList = resultItem.Select(x => x.Usage);
        return nameList.OrderBy(x => x);
    }


    public async Task Send()
    {
        if (!String.IsNullOrWhiteSpace(placeHolder) )
        {
            UserInput = placeHolder;
            TextSuppersion = false; //allows text box to be updated
            placeHolder = "";      // sets text back to empty
            IsEnterkey = true;
            await Task.Delay(2);
            TextSuppersion = true; // reset so textbox can be typed in without autoclearing until submission 
                                   //if any of the strings in PreviousCommands matches UserInput then do not add it
            if (!PreviousCommands.Contains(UserInput))
            {
                PreviousCommands.Add(UserInput);
            }
            HistoryIndex = 1;
        }
    }

    //public async Task<bool> OnEnterPress(KeyboardEventArgs e)
    //{
    //    if (!String.IsNullOrWhiteSpace(UserInput))
    //    {
    //        if (e.Code == "Enter" || e.Code == "NumpadEnter")
    //        {
    //            IsEnterkey = true;
    //            return true;
    //        }
    //        return false;
    //    }
    //    return false;
    //}



    public static async Task UpdateOutGoingTaskDic(string engineerId,string taskId, string commandHeader)
    {

        //if engineer.Id is not already a key in the EngineerUniqueInputDictionary make it a new list with the name InputList plus the engineer.Id at the end
        if (!EngineerOutboundTaskIds.ContainsKey(engineerId))
        {
            EngineerOutboundTaskIds.Add(engineerId, new List<string>());
        }
        if(EngineerOutboundTaskIds.ContainsKey(engineerId))
        {
            //add the taskid to the list of taskids for the engineerid and pass the taskId to the sendTask function
            if (!EngineerOutboundTaskIds[engineerId].Contains(taskId))
            {
                EngineerOutboundTaskIds[engineerId].Add(taskId);
                //if taskId is not in the TaskOutputHeaderInfo then add it with commandHeaderText as the value
                if (!TaskOutputHeaderInfo.ContainsKey(taskId))
                {
                    TaskOutputHeaderInfo.Add(taskId, commandHeader);
                }
            }
        }
    }


    //new task to getExistingTaskInfo 
    public static async Task GetExistingTaskInfo(Dictionary<string,List<EngineerTask>> PreviousTasks)
    {
        //pervoius tasks just holds the task id and the header text 
        //pull out the tasks from the previous tasks dictionary and add them to the EngineerOutboundTaskIds dictionary and add the task.Command and Task.Args to the TaskInputDic with Task.Id as the key
        foreach (KeyValuePair<string, List<EngineerTask>> kvp in PreviousTasks)
        {
            foreach (EngineerTask task in kvp.Value)
            {
                //var args = task.Arguments is null ? "" : string.Join(" ", task.Arguments.Select(kvp => $"{kvp.Key} {kvp.Value}"));
                if(!TaskInputDic.ContainsKey(task.Id))
                {
                    //the split should pull out the command only so engineer instructed to ls /path c:\users\ would be come ls /path c:\users\ , then split on the first non leading space so becomes ls
                    EngineerTask temp = new EngineerTask() {Id = task.Id, Command= task.Command.Split("to")[1].TrimStart().Split(' ')[0]};
                    TaskInputDic.Add(temp.Id, temp);
                }
                await UpdateOutGoingTaskDic(kvp.Key, task.Id, task.Command);
            }
        }
    }

    public async Task SendTask(Engineer engineer, string command)
    {
        string currentTaskId = Guid.NewGuid().ToString();
        var createObject = new TaskEngineerRequest();
        createObject.Command = command.Split(' ')[0];
        //if command is help then run help and return
        if (createObject.Command == "help")
        {
            Dictionary<string, string> helpDiction = new Dictionary<string, string>();
            string commandCheck = "";
            if(command.Split(' ').Length >2)
            {
                commandCheck = command.Split(' ')[2];
            }
            if(!string.IsNullOrWhiteSpace(commandCheck))
            {
                helpDiction.Add("/command", commandCheck);
            }
            string helpMenu = Help.DisplayHelp(helpDiction);


            if (!TaskOutputDic.ContainsKey(currentTaskId))
            {
                TaskOutputDic.Add(currentTaskId, helpMenu);
            }
            // split the helpmenu into lines and add each line to the list in TaskOutputDic for the currentTaskId
            //string[] helpMenuLines = helpMenu.Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
            //foreach (string line in helpMenuLines)
            //{
            //    TaskOutputDic[currentTaskId].Add(line);
            //}
            return; //return here because help command does not need to be sent to the engineers
        }

        // if command is not help keep going and parse out the arguments the user entered 
        createObject.Arguments = new Dictionary<string, string>();
        //checks if arg starts with a / and if so, it adds it to the dictionary.
        List<string> inputList = command.Split(' ').Skip(1).ToList();
        if (inputList.Count > 0)
        {
            //check if inputList ends in a space and if so, remove it
            if (inputList.Last() == "")
            {
                inputList.RemoveAt(inputList.Count - 1);
            }
            var quoteCount = 0;
            try
            {
                for (int i = 0; i < inputList.Count(); i++)
                {
                    // if the string ahead of a key holds a quote we are entering a value that should not stop collection until that quote ends.
                    if (inputList[i + 1].Contains("\\\"\""))
                    {
                        quoteCount++;
                    }
                    var input = inputList[i];
                    if (input.StartsWith("/"))
                    {
                        string result = "";
                        List<string> results;
                        // if quoteCount is even take until the next / 
                        if (quoteCount % 2 == 0)
                        {
                            results = inputList.Skip(i + 1).TakeWhile(s => !s.Contains("/")).ToList();
                            //update i based on the munber of things in results
                            i += results.Count();
                            foreach (string s in results)
                            {
                                result += " " + s;
                            }
                            result = result.TrimStart(' ');
                            createObject.Arguments.Add(input, result);
                        }
                        //if its not even we are inside a "" and should take until the next quoute
                        else
                        {
                            result = inputList[i + 1];
                            results = inputList.Skip(i + 2).TakeWhile(s => !s.Contains("\\\"\"")).ToList();
                            i += results.Count() + 2;
                            results.Add(inputList[i]);
                            foreach (string s in results)
                            {
                                result += " " + s;
                            }
                            result = result.TrimStart(' ');
                            //remove the \"" from the start and end of the result string 
                            result = result.TrimStart('\\', '\"','\"');
                            result = result.TrimEnd('\\', '\"', '\"');

                            createObject.Arguments.Add(input, result);
                            quoteCount++;
                        }
                    }
                }
            }
            catch(Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine(ex.StackTrace);
                string errorMessage = "invalid input foramt, check Client console for help.";
                Engineers.ShowErrorToast(errorMessage);
                Console.WriteLine("values with a / need to be encloused in double quoutes. values with a \" in them should not be encloused in quotes. values with both a \" & / in them need to have no spaces.");
            }  
        }
        //send the task to the server
        string resource = $"/engineers/{engineer.Id}";
        var request = new RestRequest(resource, Method.Post);
        createObject.taskID = currentTaskId;


        //if arguments contains /method as a key then if the value is sync set the IsBlocking parameter to true if its async set it to false, if the key is not present set it to false
        if (createObject.Arguments.ContainsKey("/method"))
        {
            //createObject.Arguments["/method"] = createObject.Arguments["/method"];
            if (createObject.Arguments["/method"].Equals("sync",StringComparison.CurrentCultureIgnoreCase))
            {
                createObject.IsBlocking = true;
            }
            else if (createObject.Arguments["/method"].Equals("async",StringComparison.CurrentCultureIgnoreCase))
            {
                createObject.IsBlocking = false;
            }
            else
            {
                createObject.IsBlocking = false;
            }
        }
        else
        {
            createObject.IsBlocking = false;
        }

        request.AddJsonBody(createObject);
        _ = await Task.Run(()=> restClient.PostAsync(request));
        if (TaskInputDic.ContainsKey(createObject.taskID))
        {
            TaskInputDic[createObject.taskID] = new EngineerTask { Id = createObject.taskID, Command = createObject.Command, Arguments = createObject.Arguments, File = null };
        }
        else if(!TaskInputDic.ContainsKey(createObject.taskID))
        {
            TaskInputDic.Add(createObject.taskID, new EngineerTask { Id = createObject.taskID, Command = createObject.Command, Arguments = createObject.Arguments, File = null });
        }
    }
    // end of send task function


    private async Task ExpandedChanged(bool IsChanged,string enhgineerId, string taskId)
    {
        if(IsChanged)
        {
            if (!TaskOutputDic.ContainsKey(taskId))
            {
                TaskOutputDic.Add(taskId, null);
            }
            TaskOutputDic[taskId] =  await GetTaskResults(enhgineerId, taskId);
        }
        else
        {
            TaskOutputDic.Remove(taskId);
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }
    }


    //called by signalR when a new task response comes in 
    public static async Task UpdateTaskResponse(string engineerid, List<string> returnedTaskids)
    {
        // for each returnedtaskid add it to the TaskIdQueue for the engineerid and then set the GotTaskResponse to true and set the taskid to the first taskid in the queue and execute GetTaskResults
        if (returnedTaskids != null)
        {
            // if the engineerid is not in the dictionary add it
            if (!EngineerReturnedTaskIds.ContainsKey(engineerid))
            {
                EngineerReturnedTaskIds.Add(engineerid, new List<string>());
            }
            // if the engineerid is in the dictionary check it against the tasks I know have returned already and remove them from the returnedTaskids list
            if (EngineerReturnedTaskIds.ContainsKey(engineerid))
            {
                foreach (string taskid in EngineerReturnedTaskIds[engineerid])
                {
                    if (returnedTaskids.Contains(taskid)) //&& TaskStatusDic[taskid] != EngineerTaskResponse.EngTaskStatus.Running)
                    {
                        returnedTaskids.Remove(taskid);
                    }
                }
            }

            // using the returned id list call GetTaskResults for each taskid and add the results to the EngineerTaskOutputDic
            foreach (string taskid in returnedTaskids)
            {
                if (!TaskOutputDic.ContainsKey(taskid))
                {
                    TaskOutputDic.Add(taskid, null);
                }
                TaskOutputDic[taskid] = await GetTaskResults(engineerid, taskid);
            }

        }
    }

    public static async Task<string> GetTaskResults(string engineerId, string taskid) 
    {
        //gets the task results from the server
        string resource = $"/engineers/{engineerId}/tasks/{taskid}";
        var request = new RestRequest(resource, Method.Get);
        var requestResponse = await _restClient.GetAsync<EngineerTaskResponse>(request);
        if (requestResponse != null && requestResponse.Result != null)
        {
            //if (EngineerReturnedTaskIds[engineerId].Count() <= EngineerOutboundTaskIds[engineerId].Count())
            //{
            if (!EngineerReturnedTaskIds[engineerId].Contains(taskid))
            {
                EngineerReturnedTaskIds[engineerId].Add(taskid);
            }
            //if (!TaskOutputDic.ContainsKey(taskid))
            //{
            //    TaskOutputDic.Add(taskid, new List<string>());
            //}
            var results = requestResponse.Result;

            //add the task to the TaskStatusDic and update its status
            if (!TaskStatusDic.ContainsKey(taskid))
            {
                TaskStatusDic.Add(taskid, requestResponse.status);
            }
            else
            {
                TaskStatusDic[taskid] = requestResponse.status;
            }
            return results;

            //string[] resultLines = results.Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);

            ////check to see if TaskInputDic contains the string seatbelt in any of its values
            ////if(!LinesParsedCommandsDic.ContainsKey(requestResponse.Id))
            ////{
            ////    LinesParsedCommandsDic.Add(requestResponse.Id, 0);
            ////}
            ////we clear because each time this is called we have a bigger result to display and appending is not displaying right
            //TaskOutputDic[taskid].Clear();
            //foreach (string result in resultLines)
            //{
            //    TaskOutputDic[taskid].Add(result);
            //}
            //if (TaskInputDic[taskid].Arguments.Any(s => s.Value.Contains("seatbelt")) && requestResponse.status == EngineerTaskResponse.EngTaskStatus.Complete)
            //{
            //    await ParseAndStoreCommandOutput(TaskOutputDic[taskid].ToArray(), "seatbelt", taskid, engineerId);
            //}
            //}
        }
        return "No Output";
    }

    public  async Task CancelTask(string taskid, string engineerid)
    {
        DialogOptions options = new DialogOptions() { CloseOnEscapeKey = true, MaxWidth = MaxWidth.Medium, FullWidth = true };

        var dialog = DialogService.Show<YesNoSimpleMudDialog>("Are you sure you want to cancel running task", options);
        //if the result is true then add the new profile to the list
        var result = await dialog.Result;

        if (!result.Cancelled)
        {
            await HardHatHubClient._hub.CancelRunningTask(taskid, engineerid);
            Engineers.ShowInfoToast($"Request to cancel task {taskid} sent");
        }
    }

    public static async Task ParseAndStoreCommandOutput(string[] output, string CommandName,string taskid,string engineerID)
    {
        Dictionary<string, string> commandOutput = new Dictionary<string, string>();
        List<string> outputParse = new List<string>();
        foreach (string line in output)
        {
            outputParse.Add(line);
        }
        if (CommandName == "seatbelt")
        {
            commandOutput = HardHatC2Client.Utilities.CommandOutputParsing.ParseSeatbelt(outputParse);
        }
        if(commandOutput.Count > 0)
        {
            List<string> ParsedCommandOutput = new(); 
            //List<string> commandKeys = new();
            //take each key and value from the commandOutput and join them into a string seperatted by || then add that string to the ParsedCommandOutput list
            //get the engineer object with the matching id and return its hostname
            var engineer = InteractEngineers.Where(s => s.Id == engineerID).FirstOrDefault();
            string hostname = engineer.Hostname;
            string username = engineer.Username;
            foreach(KeyValuePair<string,string> kvp in commandOutput)
            {
                ParsedCommandOutput.Add($"{kvp.Key}||{kvp.Value}");
                //commandKeys.Add(kvp.Key);
                string entityName = ReconCenter.DetermineEntity(new Dictionary<string,string>{ { "Hostname", hostname },{ "Username", username } }, CommandName, kvp.Key);
                await ReconCenter.AddAutoParsedCommandEntry(entityName, kvp.Key,kvp.Value,CommandName,hostname);
            }
            ParsedCommandOutputDic.Add(taskid, ParsedCommandOutput);
        }
    }

    private void OnShowHistoryUp(KeyboardEventArgs e)
    {
        if (PreviousCommands.Count > 0)
        {
            //check to make sure the key pressed was the up arrow
            if (e.Code == "ArrowUp")
            {
                if (HistoryIndex > PreviousCommands.Count)
                {
                    HistoryIndex = PreviousCommands.Count;
                }
                //get the Historyindex, set placeholder text to the history item at that index, and increment the index
                if (HistoryIndex <= PreviousCommands.Count)
                {
                    if (HistoryIndex == 0)
                    {
                        HistoryIndex = 1;
                    }
                    Task.Run(async () => await ForceHistoryUpdateUP());
                }
            }
            else if (e.Code == "ArrowDown")
            {
                if (HistoryIndex == 0)
                {
                    HistoryIndex = 1;
                }
                //get the Historyindex, set placeholder text to the history item at that index, and decrement the index
                if (HistoryIndex > 0)
                {
                    if (HistoryIndex == 0)
                    {
                        HistoryIndex = 1;
                    }
                    else
                    {
                        HistoryIndex--;
                        Task.Run(async () => await ForceHistoryUpdateDOWN());
                    }
                }
            }
        }
    }

    private async Task ForceHistoryUpdateUP()
    {
        TextSuppersion = false; //allows text box to be updated
        placeHolder = PreviousCommands[PreviousCommands.Count - HistoryIndex];
        await Task.Delay(2);
        TextSuppersion = true; // reset so textbox can be typed in without autoclearing until submission
        HistoryIndex++;
    }
    private async Task ForceHistoryUpdateDOWN()
    {
        TextSuppersion = false; //allows text box to be updated
        placeHolder = PreviousCommands[PreviousCommands.Count - HistoryIndex];
        await Task.Delay(2);
        TextSuppersion = true; // reset so textbox can be typed in without autoclearing until submission

    }


    protected override async Task OnInitializedAsync()
    {
        _restClient = restClient;
        Nav = navigationManagerDefault;
        // var timer = new Timer(new TimerCallback(_ =>{InvokeAsync(StateHasChanged);}), null, 100, 1000);

        stopwatch.Start();
        stopwatch2.Start();
        Task.Run(() =>
        {
            while (true)
            {
                if (stopwatch.ElapsedMilliseconds > 500)
                {
                    InvokeAsync(StateHasChanged);
                    stopwatch.Restart();
                }
                if(stopwatch2.ElapsedMilliseconds > 30000)
                {
                    GC.Collect();
                    GC.WaitForPendingFinalizers();
                    stopwatch2.Restart();
                }
                Thread.Sleep(1);
            }
        });
        if (firstRender)
        {
            foreach(KeyValuePair<string,List<string>> kvp in EngineerOutboundTaskIds)
            {
                UpdateTaskResponse(kvp.Key, kvp.Value);
            }
            firstRender = false;
            Nav.NavigateTo("/Index");
            
        }
    }
}
  
