@page "/Interact"
@using ApiModels.Requests
@using ApiModels.Responses
@using HardHatC2Client.Components;
@using HardHatC2Client.Models
@using HardHatC2Client.Services
@using HardHatC2Client.Utilities
@using BlazorXTabs
@using MudBlazor
@using RestSharp
@using System.Collections.Generic
@using System.Collections.Concurrent
@using System.Collections.ObjectModel
@using System.Linq
@using System.Diagnostics;
@using HardHatC2Client.Models.TaskResultTypes
@inject RestClient restClient
@inject NavigationManager navigationManagerDefault
@inject ISnackbar Snackbar
@inject IToastService toastService

<CascadingAuthenticationState>
    <AuthorizeView Roles="Operator,TeamLead">
        <Authorized>
            <h3 class="text-center">Interact</h3>
            <MudContainer Fixed="true">
                <MudTabs Outlined="true">
                    <MudTabPanel Text="Engineers" Icon="@Icons.Material.Filled.Build" >
                        <XTabs Style="@setTabStyle(Settings.IsCheckedBox)" IsDraggable="true" NewTabSetActive="true" RenderMode="BlazorXTabs.Configuration.RenderMode.Full" CloseTabs="true">
                            @foreach (Engineer engineer in InteractEngineers)
                            {
                                string tabTitle = EngTabTitleDic[engineer.Id];
                                <XTab Title=@tabTitle>
                                    <MudCard Class="" Style=" background:#111111; overflow-y:auto" Outlined="true"> <!--This is the parent card  -->
                                        <MudCardContent Style="background:#111111; color:white; height:850px">
                                            @if (EngineerOutboundTaskIds.ContainsKey(engineer.Id))
                                            {
                                                @foreach (string currenttask in EngineerOutboundTaskIds[engineer.Id])
                                                {
                                                    string commandHeaderText = TaskOutputHeaderInfo[currenttask]; // gets the input based on the current task index so its always unique
                                                   bool gotStatus = TaskStatusDic.TryGetValue(currenttask, out EngineerTaskResponse.EngTaskStatus status);
                                                   if(gotStatus == false)
                                                    {
                                                        status = EngineerTaskResponse.EngTaskStatus.NONE;
                                                    }
                                                    bool gotContent = TaskOutputDic.TryGetValue(currenttask, out EngineerTaskResponse cardContent);
                                                    if (gotContent == false)
                                                    {
                                                        cardContent = null;
                                                    }
                                                    bool gotTask =  TaskInputDic.TryGetValue(currenttask, out EngineerTask task);
                                                    if(gotTask == false)
                                                    {
                                                        task = null;
                                                    }
                                                    <MudExpansionPanels Style="background:#32333d; color:white;" MultiExpansion="true">
                                                    @*@if(RenderedFinalFormDic.Contains(currenttask))
                                                        {}
                                                    else
                                                    {
                                                        <InteractWindowContent HeaderContent="@commandHeaderText" engTaskStatus="@status" engineer="@engineer" CardContent="@cardContent" EngTask="@task"></InteractWindowContent>
                                                    }*@
                                                        <MudExpansionPanel IsExpandedChanged="(e)=>ExpandedChanged(e,engineer.Id,currenttask)"  style="background:#32333d; color:white;">
                                                            <TitleContent>
                                                                @if (PickedUpTasks.Contains(currenttask) && !(EngineerReturnedTaskIds.Values.Any(x => x.Contains(currenttask))))
                                                                {
                                                                    <div class="d-flex">
                                                                        <MudProgressCircular Size="Size.Small" Color="Color.Primary" Indeterminate="true" Class="mr-3" />
                                                                        <MudIconButton Icon="@Icons.Material.Filled.Cancel" Size="Size.Small" Color="Color.Error" OnClick="() =>CancelTask(currenttask,engineer.Id)"></MudIconButton>
                                                                        <MudText>@commandHeaderText</MudText>                                                   
                                                                    </div>
                                                                }
                                                                else if (EngineerReturnedTaskIds.Values.Any(x => x.Contains(currenttask) && TaskStatusDic.ContainsKey(currenttask)))
                                                                {
                                                                    if (TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Running)
                                                                    {
                                                                        <div class="d-flex">
                                                                            <MudProgressCircular Size="Size.Small" Color="Color.Primary" Indeterminate="true" Class="mr-3" />
                                                                            <MudIconButton Icon="@Icons.Material.Filled.Cancel" Size="Size.Small" Color="Color.Error" OnClick="() =>CancelTask(currenttask,engineer.Id)"></MudIconButton>
                                                                            <MudText>@commandHeaderText</MudText>

                                                                        </div>
                                                                    }
                                                                    else
                                                                    {
                                                                        <div class="d-flex">
                                                                            <MudIcon Icon=@setIcon(currenttask) Color=@SetColor(currenttask) class="mr-3"></MudIcon>
                                                                            <MudText>@commandHeaderText</MudText>
                                                                        </div>
                                                                    }
                                                                }
                                                                else
                                                                {
                                                                    <div class="d-flex">
                                                                        <MudIcon Icon=@setIcon(currenttask) Color=@SetColor(currenttask) class="mr-3"></MudIcon>
                                                                        <MudText>@commandHeaderText</MudText>
                                                                    </div>
                                                                }
                                
                                                            </TitleContent>
                                                            <ChildContent>
                                                                <MudCard Class="" Style="background:var(--background);" Outlined="true"> <!--This is the per input and output card-->
                                                                    <MudCardContent Style="background:#111111; color:white; white-space:pre-wrap;">
                                
                                                                        @if (TaskOutputDic.ContainsKey(currenttask))
                                                                        {
                                                                            <!-- <MudText>output for components go here atm thats ls command, ps command, ipconfig, anything that can use a table</MudText> -->
                                                                            // List<string> output = TaskOutputDic[currenttask];
                                                                        @if(TaskOutputDic[currenttask] !=null)
                                                                        {
                                                                            @if (TaskOutputDic[currenttask].Result != null)
                                                                            {
                                                                                @if (TaskInputDic[currenttask].Command == "ls" && TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Complete)
                                                                                {
                                                                                    TaskInputDic[currenttask].Arguments.TryGetValue("/path", out string pathValue);
                                                                                    <HardHatC2Client.Components.DirectoryListingTable Outputs="@TaskOutputDic[currenttask].Result"/>
                                                                                    if (pathValue != null)
                                                                                    {
                                                                                        pathValue = pathValue.TrimStart(' ').TrimEnd(' ');
                                                                                        FileBrowser.AddContent(engineer.Hostname, pathValue, TaskOutputDic[currenttask].Result.Deserialize<List<FileSystemItem>>());
                                                                                    }
                                                                                }
                                                                                else if (TaskInputDic[currenttask].Command == "ps" && TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Complete)
                                                                                {
                                                                                    var result = TaskOutputDic[currenttask].Result.Deserialize<string>().Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList();
                                                                                    <HardHatC2Client.Components.ProcessListingTable Outputs="@result"/>
                                                                                }
                                                                                else if (TaskInputDic[currenttask].Command == "getprivs" && TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Complete)
                                                                                {
                                                                                    var result = TaskOutputDic[currenttask].Result.Deserialize<string>().Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList();
                                                                                    <HardHatC2Client.Components.GetPrivsTable Outputs="@result"/>
                                                                                }
                                                                                else if (TaskInputDic[currenttask].Command == "print-env" && TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Complete)
                                                                                {
                                                                                    var result = TaskOutputDic[currenttask].Result.Deserialize<string>().Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList();
                                                                                        <HardHatC2Client.Components.PrintEnvTable Outputs="@result"/>
                                                                                    }
                                                                                else if (TaskInputDic[currenttask].Command.Equals("help",StringComparison.CurrentCultureIgnoreCase))
                                                                                {
                                                                                    <HelpTable Outputs="TaskOutputDic[currenttask].Result"></HelpTable> 
                                                                                }
                                                                                else if (ParsedCommandOutputDic.ContainsKey(currenttask) && TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Complete)
                                                                                {
                                                                                    <MudSwitch @bind-Checked="@IsTableView" Label="Toggle Table View" Color="Color.Success"/>
                                                                                    if (IsTableView == true)
                                                                                    {
                                                                                        <HardHatC2Client.Components.AutpParsedCommandTable Outputs="ParsedCommandOutputDic[currenttask]"></HardHatC2Client.Components.AutpParsedCommandTable>
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        var output = TaskOutputDic[currenttask].Result.Deserialize<string>();
                                                                                        <MudText Class="text-break" style="font-family:Courier New, Courier, monospace">@output</MudText>
                                                                                    }
                                                                                }
                                                                                else
                                                                                {
                                                                                    var output = TaskOutputDic[currenttask].Result.Deserialize<string>();
                                                                                    <MudText Class="text-break" style="font-family:Courier New, Courier, monospace">@output</MudText>
                                                                                }
                                                                            }
                                                                            else
                                                                            {
                                                                                <MudText Typo="Typo.body2">No output yet</MudText>
                                                                            }
                                                                        }
                                                                        }            
                                                                        else if (!TaskOutputDic.ContainsKey(currenttask))
                                                                        {
                                                                            <MudText Typo="Typo.body2">No output yet</MudText>
                                                                        }
 
                                                                    </MudCardContent>
                                                                </MudCard>  
                                                            </ChildContent>
                                                        </MudExpansionPanel><!--This is the end of per input and output card -->   
                                                    </MudExpansionPanels>
                                                }
                                            }
                                        </MudCardContent>
                                    </MudCard>
                                    <EditForm Context="EditFormContext" Model="engineer" OnValidSubmit="@Send">
                                        <div class="d-flex mb-xl-5">
                
                                            <MudAutocomplete OnKeyUp="OnShowHistoryUp" @ref="mudauto" @bind-Value=@placeHolder T="string" ResetValueOnEmptyText="true" SearchFunc="@SearchCommand"
                                                             Dense="true" Margin="Margin.Dense" SelectValueOnTab="true"  SelectOnClick="false" CoerceText="false" CoerceValue="true"
                                                             InputMode="InputMode.text" Variant="Variant.Text" Adornment="Adornment.Start" AdornmentText="[ENGINEER]> " Immediate="true" Clearable="true" KeyDownPreventDefault="true" KeyUpPreventDefault="true" TextUpdateSuppression="@TextSuppersion">
                                            </MudAutocomplete>
                                 
                                            <MudButton style="background:var(--font-color);color:var(--background)" OnClick=@Send> <MudText>Send</MudText></MudButton>
                                            @if (IsEnterkey)
                                            {
                                                Task.Run(async () => await SendTask(engineer, UserInput));
                                                IsEnterkey = false;
                                            }
                                        </div>
                                    </EditForm>
                                    <EngineerDataTable engineer="@engineer"></EngineerDataTable>
                                </XTab>
                            }
                        </XTabs>
                    </MudTabPanel>
                    <MudTabPanel Text="Browsers" Icon="@Icons.Material.Filled.FolderOpen">
                        <FileBrowser></FileBrowser>
                    </MudTabPanel>
                    <MudTabPanel Text="Terminal" Icon="@Icons.Material.Filled.Terminal" >
                        <InteractiveTerminal></InteractiveTerminal>            
                    </MudTabPanel>
                </MudTabs>
            </MudContainer>
        </Authorized>
    </AuthorizeView>
<!--This is the Start of the GUEST READ ONLY section-->
@* <AuthorizeView Roles="Guest"> *@
@*         <Authorized> *@
@*             <h3 class="text-center">Interact</h3> *@
@*             <MudContainer Fixed="true"> *@
@*         <MudTabs Outlined="true"> *@
@*             <MudTabPanel Text="Engineers" Icon="@Icons.Material.Filled.Build" > *@
@*                 <XTabs Style="@setTabStyle(Settings.IsCheckedBox)" IsDraggable="true" NewTabSetActive="true" RenderMode="BlazorXTabs.Configuration.RenderMode.Full" CloseTabs="true"> *@
@*             @foreach (Engineer engineer in InteractEngineers) *@
@*             { *@
@*                 string tabTitle = EngTabTitleDic[engineer.Id]; *@
@*                 <XTab Title=@tabTitle> *@
@*                     <MudCard Class="" Style=" background:#111111; overflow-y:auto" Outlined="true"> <!--This is the parent card  --> *@
@*                         <MudCardContent Style="background:#111111; color:white; height:800px"> *@
@*                             @if (EngineerOutboundTaskIds.ContainsKey(engineer.Id)) *@
@*                             { *@
@*                                 @foreach (string currenttask in EngineerOutboundTaskIds[engineer.Id]) *@
@*                                 { *@
@*                                         string commandHeaderText = TaskOutputHeaderInfo[currenttask]; // gets the input based on the current task index so its always unique *@
@*                                         <MudExpansionPanels Style="background:#32333d; color:white;" MultiExpansion="true"> *@
@*                                         <MudExpansionPanel IsExpandedChanged="(e)=>ExpandedChanged(e,engineer.Id,currenttask)"  style="background:#32333d; color:white;"> *@
@*                                         <TitleContent> *@
@*                                         @if (PickedUpTasks.Contains(currenttask) && !(EngineerReturnedTaskIds.Values.Any(x => x.Contains(currenttask)))) *@
@*                                         { *@
@*                                             <div class="d-flex"> *@
@*                                                 <MudProgressCircular Size="Size.Small" Color="Color.Primary" Indeterminate="true" Class="mr-3" /> *@
@*                                                 <MudIconButton Disabled="true" Icon="@Icons.Material.Filled.Cancel" Size="Size.Small" Color="Color.Error" OnClick="() =>CancelTask(currenttask,engineer.Id)"></MudIconButton> *@
@*                                                 <MudText>@commandHeaderText</MudText>                                                    *@
@*                                             </div> *@
@*                                         } *@
@*                                         else if (EngineerReturnedTaskIds.Values.Any(x => x.Contains(currenttask) && TaskStatusDic.ContainsKey(currenttask))) *@
@*                                         { *@
@*                                             if (TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Running) *@
@*                                             { *@
@*                                                 <div class="d-flex"> *@
@*                                                     <MudProgressCircular Size="Size.Small" Color="Color.Primary" Indeterminate="true" Class="mr-3" /> *@
@*                                                     <MudIconButton Icon="@Icons.Material.Filled.Cancel" Size="Size.Small" Color="Color.Error" OnClick="() =>CancelTask(currenttask,engineer.Id)"></MudIconButton> *@
@*                                                     <MudText>@commandHeaderText</MudText> *@
@*          *@
@*                                                 </div> *@
@*                                             } *@
@*                                             else *@
@*                                             { *@
@*                                                 <div class="d-flex"> *@
@*                                                     <MudIcon Icon=@setIcon(currenttask) Color=@SetColor(currenttask) class="mr-3"></MudIcon> *@
@*                                                     <MudText>@commandHeaderText</MudText> *@
@*                                                 </div> *@
@*                                             } *@
@*                                         } *@
@*                                         else *@
@*                                         { *@
@*                                             <div class="d-flex"> *@
@*                                                 <MudIcon Icon=@setIcon(currenttask) Color=@SetColor(currenttask) class="mr-3"></MudIcon> *@
@*                                                 <MudText>@commandHeaderText</MudText> *@
@*                                             </div> *@
@*                                         } *@
@*                                          *@
@*                                         </TitleContent> *@
@*                                         <ChildContent> *@
@*                                         <MudCard Class="" Style="background:var(--background);" Outlined="true"> <!--This is the per input and output card--> *@
@*                                         <MudCardContent Style="background:#111111; color:white; white-space:pre-wrap;"> *@
@*                                          *@
@*                                             @if (TaskOutputDic.ContainsKey(currenttask)) *@
@*                                             { *@
@*                                                 <!-- <MudText>output for components go here atm thats ls command, ps command, ipconfig, anything that can use a table</MudText> --> *@
@*                                                 // List<string> output = TaskOutputDic[currenttask]; *@
@*                                                 @if(TaskOutputDic[currenttask].Result !=null) *@
@*                                                 { *@
@*                                                     @if (TaskInputDic[currenttask].Command =="ls" && TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Complete ) *@
@*                                                     { *@
@*                                                         TaskInputDic[currenttask].Arguments.TryGetValue("/path", out string pathValue); *@
@*                                                          *@
@*                                                         <HardHatC2Client.Components.DirectoryListingTable Outputs="@TaskOutputDic[currenttask].Result" /> *@
@*                                                         if (pathValue != null) *@
@*                                                         { *@
@*                                                             pathValue = pathValue.TrimStart(' ').TrimEnd(' '); *@
@*                                                             FileBrowser.AddContent(engineer.Hostname, pathValue,TaskOutputDic[currenttask].Result.Deserialize<List<FileSystemItem>>() ); *@
@*                                                         } *@
@*                                                     } *@
@*                                                     else if (TaskInputDic[currenttask].Command == "ps" && TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Complete) *@
@*                                                     { *@
@*                                                         <HardHatC2Client.Components.ProcessListingTable Outputs="@TaskOutputDic[currenttask].Result.Deserialize<string>().Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList()" /> *@
@*                                                     } *@
@*                                                     else if (TaskInputDic[currenttask].Command == "getprivs" && TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Complete) *@
@*                                                     { *@
@*                                                         <HardHatC2Client.Components.GetPrivsTable Outputs="@TaskOutputDic[currenttask].Result.Deserialize<string>().Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList()" /> *@
@*                                                     } *@
@*                                                     else if (TaskInputDic[currenttask].Command == "print-env" && TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Complete) *@
@*                                                     { *@
@*                                                         <HardHatC2Client.Components.PrintEnvTable Outputs="@TaskOutputDic[currenttask].Result.Deserialize<string>().Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList()" /> *@
@*                                                     } *@
@*                                                     else if (ParsedCommandOutputDic.ContainsKey(currenttask) && TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Complete) *@
@*                                                     { *@
@*                                                         <MudSwitch @bind-Checked="@IsTableView" Label="Toggle Table View" Color="Color.Success" /> *@
@*                                                         if(IsTableView) *@
@*                                                         { *@
@*                                                             <HardHatC2Client.Components.AutpParsedCommandTable Outputs="ParsedCommandOutputDic[currenttask]"></HardHatC2Client.Components.AutpParsedCommandTable> *@
@*                                                         } *@
@*                                                         else *@
@*                                                         { *@
@*                                                             <MudText Class="text-break" style="font-family:Courier New, Courier, monospace">@TaskOutputDic[currenttask].Result.Deserialize<string>()</MudText> *@
@*                                                         } *@
@*                                                     } *@
@*                                                     else *@
@*                                                     { *@
@*                                                         <MudText Class="text-break" style="font-family:Courier New, Courier, monospace">@TaskOutputDic[currenttask].Result.Deserialize<string>()</MudText> *@
@*                                                     } *@
@*                                                 } *@
@*                                             }              *@
@*                                             else if (!TaskOutputDic.ContainsKey(currenttask)) *@
@*                                             { *@
@*                                                 <MudText Typo="Typo.body2">No output yet</MudText> *@
@*                                             } *@
@*                                         </MudCardContent> *@
@*                                     </MudCard>   *@
@*                                      </ChildContent> *@
@*                                     </MudExpansionPanel><!--This is the end of per input and output card -->    *@
@*                                     </MudExpansionPanels> *@
@*                                 } *@
@*                             } *@
@*                         </MudCardContent> *@
@*                     </MudCard> *@
@*                     <div class="d-flex mb-xl-5"> *@
@*                          *@
@*                             <MudAutocomplete Disabled="true" OnKeyUp="OnShowHistoryUp" @ref="mudauto" @bind-Value=@placeHolder T="string" ResetValueOnEmptyText="true" SearchFunc="@SearchCommand" *@
@*                                            Dense="true" Margin="Margin.Dense" SelectValueOnTab="true"  SelectOnClick="false" CoerceText="false" CoerceValue="true" *@
@*                                              InputMode="InputMode.text" Variant="Variant.Text" Adornment="Adornment.Start" AdornmentText="[ENGINEER]> " Immediate="true" Clearable="true" KeyDownPreventDefault="true" KeyUpPreventDefault="true" TextUpdateSuppression="@TextSuppersion"> *@
@*                         </MudAutocomplete> *@
@*                                           *@
@*                         <MudButton Disabled="true" style="background:var(--font-color);color:var(--background)" OnClick=@Send> <MudText>Send</MudText></MudButton> *@
@*                         @if (IsEnterkey) *@
@*                         { *@
@*                             Task.Run(async () => await SendTask(engineer, UserInput)); *@
@*                             IsEnterkey = false; *@
@*                         } *@
@*                     </div> *@
@*                     <EngineerDataTable engineer="@engineer"></EngineerDataTable> *@
@*                 </XTab> *@
@*             } *@
@*         </XTabs> *@
@*             </MudTabPanel> *@
@*             <MudTabPanel Text="Browsers" Icon="@Icons.Material.Filled.FolderOpen"> *@
@*                                 <FileBrowser></FileBrowser> *@
@*             </MudTabPanel> *@
@*             <MudTabPanel Text="Terminal" Icon="@Icons.Material.Filled.Terminal" > *@
@*                 <InteractiveTerminal></InteractiveTerminal>             *@
@*             </MudTabPanel> *@
@*         </MudTabs> *@
@*         </MudContainer> *@
@*         </Authorized> *@
@* </AuthorizeView> *@
<AuthorizeView Roles="Operator,TeamLead,Guest">
    <NotAuthorized>
        <h1 class="text-center">Not Authorized</h1>
        <HardHatC2Client.Components.UnAuthorizedDialogBox></HardHatC2Client.Components.UnAuthorizedDialogBox>
    </NotAuthorized>
</AuthorizeView>
</CascadingAuthenticationState>

@code {
    [Inject] 
    private IDialogService DialogService { get; set; }
    [Inject]
    private static RestClient _restClient { get; set; }
    [Inject]
    private static NavigationManager Nav { get; set; }
    private static Dictionary<string,List<string>> EngineerOutboundTaskIds = new(); // key is engineer id, value is list of task ids
    private static Dictionary<string,EngineerTask> TaskInputDic = new(); // first key is taskId and value is the userInput for commands


    private static Dictionary<string,List<string>> EngineerReturnedTaskIds = new(); // key is engineer id, value is list of task ids
    internal static Dictionary<string,EngineerTaskResponse> TaskOutputDic = new(); // first key is taskID and value is the output from the task
    private static Dictionary<string, EngineerTaskResponse.EngTaskStatus> TaskStatusDic = new(); // first key is taskID and value is the status of the task

    private static Dictionary<string, string> TaskOutputHeaderInfo = new(); // first key is taskID and value is the task output header 
    public static List<Engineer> InteractEngineers = new(); // list of the engineerrs the user has added for interaction 

    public static Dictionary<string, string> EngTabTitleDic = new(); // key is engineer id, value is the tab title

    public static Dictionary<string, List<string>> ParsedCommandOutputDic = new(); // key is task id, value is a dictionary of properties containing the property name and value
    public static Dictionary<string, int> LinesParsedCommandsDic = new();
    public static List<string> RenderedFinalFormDic = new List<string>();

    public static List<string> PickedUpTasks = new();

    private static string UserInput { get; set;}
    private string placeHolder = null;
    private bool IsEnterkey { get; set; } = false;
    //private static Command userCommand = new Command();
    private MudAutocomplete<string> mudauto { get; set; }
    private Engineer currentEng = null;
    private static List<string> PreviousCommands = new();
    private string selectedHistoryCommand = null;
    private static int HistoryIndex = 1;

    private string icon = Icons.Material.Filled.CheckCircle;
    private static bool TextSuppersion = true;
    private static bool IsTableView = true;
    private static bool firstRender = true;
    private static bool Initialized = false;

    private static Stopwatch stopwatch = new Stopwatch();
    private static Stopwatch stopwatch2 = new Stopwatch();

    private static string OutputOneStringTest = "";
    //create a delegate that we can use to invoke statehaschanged 
    public delegate void OnStateChangeDelegate();
    public static OnStateChangeDelegate OnStateChange;
    private static DateTime? LastRefresh { get; set; } = null;



    private string setTabStyle(bool IsDark)
    {
        if(IsDark)
        {
            return "background:#32333d; color:white;";
        }
        return "background:white; color:black;";  
    }

    //set the icon and color for commands 
    private string setIcon(string currenttask)
    {
        if (TaskStatusDic.ContainsKey(currenttask))
        {
            if (TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Complete)
            {
                return Icons.Filled.CheckCircle;
            }
            else if (TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Cancelled)
            {
                return Icons.Filled.StopCircle;
            }
            else if (TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Failed)
            {
                return Icons.Filled.SmsFailed;
            }
            else if (TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.FailedWithWarnings)
            {
                return Icons.Filled.Warning;
            }
            else
            {
                return Icons.Filled.Info;
            }
        }
        else
        {
            return Icons.Filled.Info;
        }
    }

    private Color SetColor(string currenttask)
    {
        if (TaskStatusDic.ContainsKey(currenttask))
        {
            if (TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Complete)
            {
                return Color.Success;
            }
            else if (TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Cancelled)
            {
                return Color.Secondary;
            }
            else if (TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.Failed)
            {
                return Color.Error;
            }
            else if (TaskStatusDic[currenttask] == EngineerTaskResponse.EngTaskStatus.FailedWithWarnings)
            {
                return Color.Warning;
            }
            else
            {
                return Color.Info;
            }
        }
        else
        {
            return Color.Info;
        }
    }

    public static async Task AddTaskToPickedUpList(string taskid)
    {
        if (!PickedUpTasks.Contains(taskid))
        {
            PickedUpTasks.Add(taskid);
        }
        if (OnStateChange is not null)
        {
            OnStateChange();
        }
    }


    public void ImplementOnStateChangeEvent()
    {
        if (LastRefresh == null)
        {
            LastRefresh = DateTime.Now;
            InvokeAsync(StateHasChanged);
        }
        else
        {
            // if more then 500 ms has passed since the last refresh then refresh the page
            if (DateTime.Now.Subtract(LastRefresh.Value).TotalMilliseconds > 500)
            {
                LastRefresh = DateTime.Now;
                InvokeAsync(StateHasChanged);
            }
        }
    }


    private async Task<IEnumerable<string>> SearchCommand(string value)
    {
        //if input is blank or null give the whole list. 
        if (string.IsNullOrEmpty(value))
        {
            var list = Help.menuItems.Select(x => x.Usage);
            //alpabatize the list by the Name before returning it 
            return list.OrderBy(x => x);
        }
        //return the name of the Help.MenuItem that matches the search term
        var resultItem = await Task.FromResult(Help.menuItems.Where(x => x.Name.ToLower().Contains(value.ToLower())).ToList());
        //alphabetize and return the list
        var nameList = resultItem.Select(x => x.Usage);
        return nameList.OrderBy(x => x);
    }


    public async Task Send()
    {
        if (!String.IsNullOrWhiteSpace(placeHolder) )
        {
            UserInput = placeHolder;
            TextSuppersion = false; //allows text box to be updated
            placeHolder = "";      // sets text back to empty
            IsEnterkey = true;
            await Task.Delay(2);
            TextSuppersion = true; // reset so textbox can be typed in without autoclearing until submission 
                                   //if any of the strings in PreviousCommands matches UserInput then do not add it
            if (OnStateChange is not null)
            {
                OnStateChange();
            }
            if (!PreviousCommands.Contains(UserInput))
            {
                PreviousCommands.Add(UserInput);
            }
            HistoryIndex = 1;
        }
    }



    public static async Task UpdateOutGoingTaskDic(string engineerId,string taskId, string commandHeader)
    {
        //if engineer.Id is not already a key in the EngineerUniqueInputDictionary make it a new list with the name InputList plus the engineer.Id at the end
        if (!EngineerOutboundTaskIds.ContainsKey(engineerId))
        {
            EngineerOutboundTaskIds.Add(engineerId, new List<string>());
        }
        if(EngineerOutboundTaskIds.ContainsKey(engineerId))
        {
            //add the taskid to the list of taskids for the engineerid and pass the taskId to the sendTask function
            if (!EngineerOutboundTaskIds[engineerId].Contains(taskId))
            {
                EngineerOutboundTaskIds[engineerId].Add(taskId);
                //if taskId is not in the TaskOutputHeaderInfo then add it with commandHeaderText as the value
                if (!TaskOutputHeaderInfo.ContainsKey(taskId))
                {
                    TaskOutputHeaderInfo.Add(taskId, commandHeader);
                }
            }
        }
        if (OnStateChange is not null)
        {
            OnStateChange();
        }
    }


    //new task to getExistingTaskInfo 
    public static async Task GetExistingTaskInfo(Dictionary<string,List<EngineerTask>> PreviousTasks)
    {
        //pervoius tasks just holds the task id and the header text 
        //pull out the tasks from the previous tasks dictionary and add them to the EngineerOutboundTaskIds dictionary and add the task.Command and Task.Args to the TaskInputDic with Task.Id as the key
        foreach (KeyValuePair<string, List<EngineerTask>> kvp in PreviousTasks)
        {
            foreach (EngineerTask task in kvp.Value)
            {
                //var args = task.Arguments is null ? "" : string.Join(" ", task.Arguments.Select(kvp => $"{kvp.Key} {kvp.Value}"));
                if(!TaskInputDic.ContainsKey(task.Id))
                {
                    //the split should pull out the command only so engineer instructed to ls /path c:\users\ would be come ls /path c:\users\ , then split on the first non leading space so becomes ls
                    EngineerTask temp = new EngineerTask() {Id = task.Id, Command= task.Command.Split("to")[1].TrimStart().Split(' ')[0], Arguments = task.Arguments};
                    TaskInputDic.Add(temp.Id, temp);
                }
                await UpdateOutGoingTaskDic(kvp.Key, task.Id, task.Command);
            }
        }
        if (OnStateChange is not null)
        {
            OnStateChange();
        }
    }

    public static async Task SendTask(Engineer engineer, string command)
    {
        string currentTaskId = Guid.NewGuid().ToString();
        var createObject = new TaskEngineerRequest();
        createObject.Command = command.Split(' ')[0];
        //if command is help then run help and return
        if (createObject.Command.Trim().Equals("help",StringComparison.CurrentCultureIgnoreCase))
        {
            Dictionary<string, string> helpDiction = new Dictionary<string, string>();
            string commandCheck = "";
            string helpCommandheader = "";
            if(command.Split(' ').Length >2)
            {
                commandCheck = command.Split(' ')[2];
                helpCommandheader = $"({DateTime.UtcNow}) Engineer instructed to {createObject.Command} {command.Split(' ')[1]} {command.Split(' ')[2]}\n";
            }
            else
            {
                helpCommandheader = $"({DateTime.UtcNow}) Engineer instructed to {createObject.Command}\n";
            }
            if(!string.IsNullOrWhiteSpace(commandCheck))
            {
                helpDiction.Add("/command", commandCheck);
            }
            List<Help.HelpMenuItem> helpMenu = Help.DisplayHelp(helpDiction);
            

            if (!TaskOutputDic.ContainsKey(currentTaskId))
            {
                if (!TaskInputDic.ContainsKey(currentTaskId))
                {
                    TaskInputDic.Add(currentTaskId, new EngineerTask { Id = currentTaskId, Command = createObject.Command, Arguments = helpDiction, File = null });
                }
                await UpdateOutGoingTaskDic(engineer.Id, currentTaskId, helpCommandheader);
                var taskResponse = new EngineerTaskResponse();
                taskResponse.Id = currentTaskId;
                taskResponse.status = EngineerTaskResponse.EngTaskStatus.Complete;
                taskResponse.ResponseType = EngineerTaskResponse.TaskResponseType.HelpMenuItem;
                taskResponse.Result = helpMenu.Serialise();
                TaskOutputDic.Add(currentTaskId,taskResponse);
                if (!TaskStatusDic.ContainsKey(currentTaskId))
                {
                    TaskStatusDic.Add(currentTaskId, taskResponse.status);
                }
            }
            return; //return here because help command does not need to be sent to the engineers
        }

        // if command is not help keep going and parse out the arguments the user entered 
        createObject.Arguments = new Dictionary<string, string>();
        //checks if arg starts with a / and if so, it adds it to the dictionary.
        List<string> inputList = command.Split(' ').Skip(1).ToList();
        if (inputList.Count > 0)
        {
            //check if inputList ends in a space and if so, remove it
            if (inputList.Last() == "")
            {
                inputList.RemoveAt(inputList.Count - 1);
            }
            var quoteCount = 0;
            try
            {
                for (int i = 0; i < inputList.Count(); i++)
                {
                    // if the string ahead of a key holds a quote we are entering a value that should not stop collection until that quote ends.
                    if (inputList[i + 1].Contains("\\\"\""))
                    {
                        quoteCount++;
                    }
                    var input = inputList[i];
                    if (input.StartsWith("/"))
                    {
                        string result = "";
                        List<string> results;
                        // if quoteCount is even take until the next / 
                        if (quoteCount % 2 == 0)
                        {
                            results = inputList.Skip(i + 1).TakeWhile(s => !s.Contains("/")).ToList();
                            //update i based on the munber of things in results
                            i += results.Count();
                            foreach (string s in results)
                            {
                                result += " " + s;
                            }
                            result = result.TrimStart(' ');
                            createObject.Arguments.Add(input, result);
                        }
                        //if its not even we are inside a "" and should take until the next quoute
                        else
                        {
                            result = inputList[i + 1];
                            results = inputList.Skip(i + 2).TakeWhile(s => !s.Contains("\\\"\"")).ToList();
                            i += results.Count() + 2;
                            results.Add(inputList[i]);
                            foreach (string s in results)
                            {
                                result += " " + s;
                            }
                            result = result.TrimStart(' ');
                            //remove the \"" from the start and end of the result string 
                            result = result.TrimStart('\\', '\"','\"');
                            result = result.TrimEnd('\\', '\"', '\"');

                            createObject.Arguments.Add(input, result);
                            quoteCount++;
                        }
                    }
                }
            }
            catch(Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine(ex.StackTrace);
                string errorMessage = "invalid input foramt, check Client console for help.";
                Engineers.ShowErrorToast(errorMessage);
                Console.WriteLine("values with a / need to be encloused in double quoutes. values with a \" in them should not be encloused in quotes. values with both a \" & / in them need to have no spaces.");
            }  
        }

        //assign the task id to the task    
        createObject.taskID = currentTaskId;

        //if arguments contains /method as a key then if the value is sync set the IsBlocking parameter to true if its async set it to false, if the key is not present set it to false
        if (createObject.Arguments.ContainsKey("/method"))
        {
            //createObject.Arguments["/method"] = createObject.Arguments["/method"];
            if (createObject.Arguments["/method"].Equals("sync",StringComparison.CurrentCultureIgnoreCase))
            {
                createObject.IsBlocking = true;
            }
            else if (createObject.Arguments["/method"].Equals("async",StringComparison.CurrentCultureIgnoreCase))
            {
                createObject.IsBlocking = false;
            }
            else
            {
                createObject.IsBlocking = false;
            }
        }
        else
        {
            createObject.IsBlocking = false;
        }

        //update the input dictionary with the new task
        if (TaskInputDic.ContainsKey(createObject.taskID))
        {
            TaskInputDic[createObject.taskID] = new EngineerTask { Id = createObject.taskID, Command = createObject.Command, Arguments = createObject.Arguments, File = null };
        }
        else if(!TaskInputDic.ContainsKey(createObject.taskID))
        {
            TaskInputDic.Add(createObject.taskID, new EngineerTask { Id = createObject.taskID, Command = createObject.Command, Arguments = createObject.Arguments, File = null });
        }
        if (OnStateChange is not null)
        {
            OnStateChange();
        }

        //update the local outgoing header to make it apear faster upon submit
        var args = createObject.Arguments is null ? "" : string.Join(" ", createObject.Arguments.Select(kvp => $"{kvp.Key} {kvp.Value}"));
        string Commandheader = $"({DateTime.UtcNow}) Engineer instructed to {createObject.Command + " " + args}\n";
        Task.Run(async() => await UpdateOutGoingTaskDic(engineer.Id,currentTaskId,Commandheader));
        if (OnStateChange is not null)
        {
            OnStateChange();
        }

        //send the task to the server
        string resource = $"/engineers/{engineer.Id}";
        var request = new RestRequest(resource, Method.Post);
        request.AddJsonBody(createObject);
        _ = await Task.Run(()=> _restClient.PostAsync(request));
    }
    // end of send task function


    public static async Task ExpandedChanged(bool IsChanged,string enhgineerId, string taskId)
    {
        try
        {
            //check if task command is help if so skip 
            if(TaskInputDic[taskId].Command.Equals("help",StringComparison.CurrentCultureIgnoreCase))
            {
                return;
            }

            if(IsChanged)
            {
                if (!TaskOutputDic.ContainsKey(taskId))
                {
                    var taskInfo = await GetTaskResults(enhgineerId, taskId);
                    TaskOutputDic.Add(taskId, taskInfo);
                }
                if (OnStateChange is not null)
                {
                    OnStateChange();
                }
            }
            else
            {
                TaskOutputDic.Remove(taskId);
                if (OnStateChange is not null)
                {
                    OnStateChange();
                }
                GC.Collect();
                GC.WaitForPendingFinalizers();
            }

        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
            Console.WriteLine(e.StackTrace);
        }

    }


    //called by signalR when a new task response comes in 
    public static async Task UpdateTaskResponse(string engineerid, List<string> returnedTaskids)
    {
        // for each returnedtaskid add it to the TaskIdQueue for the engineerid and then set the GotTaskResponse to true and set the taskid to the first taskid in the queue and execute GetTaskResults
        if (returnedTaskids != null)
        {
            // if the engineerid is not in the dictionary add it
            if (!EngineerReturnedTaskIds.ContainsKey(engineerid))
            {
                EngineerReturnedTaskIds.Add(engineerid, new List<string>());
            }
            // if the engineerid is in the dictionary check it against the tasks I know have returned already and remove them from the returnedTaskids list
            if (EngineerReturnedTaskIds.ContainsKey(engineerid))
            {
                foreach (string taskid in EngineerReturnedTaskIds[engineerid])
                {
                    if (returnedTaskids.Contains(taskid)) //&& TaskStatusDic[taskid] != EngineerTaskResponse.EngTaskStatus.Running)
                    {
                        returnedTaskids.Remove(taskid);
                    }
                }
            }

            // using the returned id list call GetTaskResults for each taskid and add the results to the EngineerTaskOutputDic
            foreach (string taskid in returnedTaskids)
            {
                if (!TaskOutputDic.ContainsKey(taskid))
                {
                    TaskOutputDic.Add(taskid, null);
                }
                TaskOutputDic[taskid] = await GetTaskResults(engineerid, taskid);
                //if TaskOutputDic[taskid] == No Output then remove the taskid from the TaskOutputDic
                if (TaskOutputDic[taskid] != null)
                {
                    if (TaskOutputDic[taskid].Result.Deserialize<string>() == "No Output")
                    {
                        TaskOutputDic.Remove(taskid);
                    }
                }
                //check the taskid against the taskInputDic to see if its an ls command if so then we can send data to the file browser component
                if (TaskInputDic.ContainsKey(taskid))
                {
                    if (TaskInputDic[taskid].Command == "ls")
                    {
                        if (TaskOutputDic[taskid] != null)
                        {
                            if (TaskOutputDic[taskid].Result.Deserialize<string>().Contains("No Output"))
                            {
                                TaskOutputDic[taskid] = null;
                            }
                            else
                            {
                                //send the output to the file browser component
                                //find the engineer object this task belongs to
                                Engineer engineer = null;
                                foreach (Engineer eng in Engineers.EngineerList)
                                {
                                    if (eng.Id == engineerid)
                                    {
                                        engineer = eng;
                                    }
                                }
                                //check the task status to see if it was successful
                                if (TaskStatusDic[taskid] == EngineerTaskResponse.EngTaskStatus.Complete)
                                {
                                    bool gotOutput = TaskInputDic[taskid].Arguments.TryGetValue("/path", out string pathValue);
                                    if (gotOutput)
                                    {
                                        pathValue = pathValue.TrimStart(' ').TrimEnd(' ');
                                        FileBrowser.AddContent(engineer.Hostname, pathValue, TaskOutputDic[taskid].Result.Deserialize<List<FileSystemItem>>());
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (OnStateChange is not null)
            {
                OnStateChange();
            }

        }
    }

    public static async Task<EngineerTaskResponse> GetTaskResults(string engineerId, string taskid) 
    {
        try
        {
            if (_restClient is not null)
            {
                //gets the task results from the server
                string resource = $"/engineers/{engineerId}/tasks/{taskid}";
                var request = new RestRequest(resource, Method.Get);
                var requestResponse = await _restClient.GetAsync<EngineerTaskResponse>(request);
                if (requestResponse != null && requestResponse.Result != null)
                {
                    if(!EngineerReturnedTaskIds.ContainsKey(engineerId))
                    {
                        EngineerReturnedTaskIds.Add(engineerId, new List<string>());
                    }
                    if (!EngineerReturnedTaskIds[engineerId].Contains(taskid))
                    {
                        EngineerReturnedTaskIds[engineerId].Add(taskid);
                    }
                    // var results = requestResponse.Result;
                    //
                    // //add the task to the TaskStatusDic and update its status
                    if (!TaskStatusDic.ContainsKey(taskid))
                    {
                        TaskStatusDic.Add(taskid, requestResponse.status);
                    }
                    else
                    {
                        TaskStatusDic[taskid] = requestResponse.status;
                    }
                    if (OnStateChange is not null)
                    {
                        OnStateChange();
                    }
                    return requestResponse;
                }
                return null;
            }
            return null;

        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
            Console.WriteLine(e.StackTrace);
            return null;
        }

    }

    public  async Task CancelTask(string taskid, string engineerid)
    {
        DialogOptions options = new DialogOptions() { CloseOnEscapeKey = true, MaxWidth = MaxWidth.Medium, FullWidth = true };

        var dialog = DialogService.Show<YesNoSimpleMudDialog>("Are you sure you want to cancel running task", options);
        //if the result is true then add the new profile to the list
        var result = await dialog.Result;

        if (!result.Cancelled)
        {
            await HardHatHubClient._hub.CancelRunningTask(taskid, engineerid);
            Engineers.ShowInfoToast($"Request to cancel task {taskid} sent");
        }
        if (OnStateChange is not null)
        {
            OnStateChange();
        }
    }

    public static async Task ParseAndStoreCommandOutput(string[] output, string CommandName,string taskid,string engineerID)
    {
        Dictionary<string, string> commandOutput = new Dictionary<string, string>();
        List<string> outputParse = new List<string>();
        foreach (string line in output)
        {
            outputParse.Add(line);
        }
        if (CommandName == "seatbelt")
        {
            commandOutput = HardHatC2Client.Utilities.CommandOutputParsing.ParseSeatbelt(outputParse);
        }
        if(commandOutput.Count > 0)
        {
            List<string> ParsedCommandOutput = new(); 
            //List<string> commandKeys = new();
            //take each key and value from the commandOutput and join them into a string seperatted by || then add that string to the ParsedCommandOutput list
            //get the engineer object with the matching id and return its hostname
            var engineer = InteractEngineers.Where(s => s.Id == engineerID).FirstOrDefault();
            string hostname = engineer.Hostname;
            string username = engineer.Username;
            foreach(KeyValuePair<string,string> kvp in commandOutput)
            {
                ParsedCommandOutput.Add($"{kvp.Key}||{kvp.Value}");
                //commandKeys.Add(kvp.Key);
                string entityName = ReconCenter.DetermineEntity(new Dictionary<string,string>{ { "Hostname", hostname },{ "Username", username } }, CommandName, kvp.Key);
                await ReconCenter.AddAutoParsedCommandEntry(entityName, kvp.Key,kvp.Value,CommandName,hostname);
            }
            ParsedCommandOutputDic.Add(taskid, ParsedCommandOutput);
        }
    }

    private void OnShowHistoryUp(KeyboardEventArgs e)
    {
        if (PreviousCommands.Count > 0)
        {
            //check to make sure the key pressed was the up arrow
            if (e.Code == "ArrowUp")
            {
                if (HistoryIndex > PreviousCommands.Count)
                {
                    HistoryIndex = PreviousCommands.Count;
                }
                //get the Historyindex, set placeholder text to the history item at that index, and increment the index
                if (HistoryIndex <= PreviousCommands.Count)
                {
                    if (HistoryIndex == 0)
                    {
                        HistoryIndex = 1;
                    }
                    Task.Run(async () => await ForceHistoryUpdateUP());
                }
            }
            else if (e.Code == "ArrowDown")
            {
                if (HistoryIndex == 0)
                {
                    HistoryIndex = 1;
                }
                //get the Historyindex, set placeholder text to the history item at that index, and decrement the index
                if (HistoryIndex > 0)
                {
                    if (HistoryIndex == 0)
                    {
                        HistoryIndex = 1;
                    }
                    else
                    {
                        HistoryIndex--;
                        Task.Run(async () => await ForceHistoryUpdateDOWN());
                    }
                }
            }
        }
        if (OnStateChange is not null)
        {
            OnStateChange();
        }
    }

    private async Task ForceHistoryUpdateUP()
    {
        TextSuppersion = false; //allows text box to be updated
        placeHolder = PreviousCommands[PreviousCommands.Count - HistoryIndex];
        await Task.Delay(2);
        TextSuppersion = true; // reset so textbox can be typed in without autoclearing until submission
        HistoryIndex++;
        if (OnStateChange is not null)
        {
            OnStateChange();
        }
    }
    private async Task ForceHistoryUpdateDOWN()
    {
        TextSuppersion = false; //allows text box to be updated
        placeHolder = PreviousCommands[PreviousCommands.Count - HistoryIndex];
        await Task.Delay(2);
        TextSuppersion = true; // reset so textbox can be typed in without autoclearing until submission
        if (OnStateChange is not null)
        {
            OnStateChange();
        }
    }


    protected override async Task OnInitializedAsync()
    {
        OnStateChange = ImplementOnStateChangeEvent;
        _restClient = restClient;
        Nav = navigationManagerDefault;
        // if (stopwatch2.IsRunning == false)
        // {
        //     stopwatch2.Start();
        //     Task.Run(() =>
        //     {
        //         while (true)
        //         {
        //             if (stopwatch2.ElapsedMilliseconds > 500)
        //             {
        //                 OnStateChange();
        //                 stopwatch2.Restart();
        //             }
        //             Thread.Sleep(100);
        //         }
        //     });
        // }
            if (firstRender && _restClient is not null)
            {
                foreach (KeyValuePair<string, List<string>> kvp in EngineerOutboundTaskIds)
                {
                    UpdateTaskResponse(kvp.Key, kvp.Value);
                }
                firstRender = false;
                Nav.NavigateTo("/Index");
            }
        
        OnStateChange();
    }
}
  
