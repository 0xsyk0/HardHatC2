@page "/Interact"
@using ApiModels.Requests
@using ApiModels.Responses
@using ApiModels.Shared;
@using Blazored.LocalStorage;
@using HardHatC2Client.Components;
@using HardHatC2Client.Models
@using HardHatC2Client.Services
@using HardHatC2Client.Utilities
@using BlazorXTabs
@using MudBlazor
@using RestSharp
@using System.Collections.Generic
@using System.Collections.Concurrent
@using System.Collections.ObjectModel
@using System.Linq
@using System.Diagnostics;
@using HardHatC2Client.Models.TaskResultTypes
@using RestSharp.Authenticators;
@using System.Text.RegularExpressions;
@using static HardHatC2Client.Utilities.Help;
@inject RestClient restClient
@inject NavigationManager navigationManagerDefault
@inject ISnackbar Snackbar
@inject IToastService toastService

<style>
    .dialog-blur-class {
        backdrop-filter: blur(10px);
    }
</style>

<CascadingAuthenticationState>
    <AuthorizeView Roles="Operator,TeamLead">
        <Authorized>
            <h3 class="text-center">Interact</h3>
                <MudContainer Fixed="true">
                <MudTabs Outlined="true">
                    <MudTabPanel Text="Engineers" Icon="@Icons.Material.Filled.Build" >
                        <div class="d-flex">
                        <MudSwitch @bind-Checked="@removeContentSwitch" Label="Remove panel content on collapse" Color="Color.Primary"></MudSwitch>
                        <MudTooltip ShowOnHover="true" Arrow="true" Placement="Placement.Right">
                            <ChildContent>
                                <MudIconButton Class="mx-2" Icon="@Icons.Material.Outlined.Info" />
                            </ChildContent>
                        <TooltipContent>
                                <MudText>
                                    When enabled once a panel is closed its content is removed from the client saving ram.
                                </MudText>
                                    <MudText>
                                    Downside is panel expansion time will be slower because when reopened it will wait on the team server to return the task output.
                                    </MudText>
                                        <MudText>
                                    Disabling can help with responsiveness of the panels and some content display bugs.
                                </MudText>
                        </TooltipContent>
                        </MudTooltip>
                        <MudIconButton Class="mx-2" Icon="@Icons.Material.Filled.EditNote" @onclick="ShowAliasDialog"></MudIconButton>
                            <MudSlider  ValueLabel="true" @bind-Value="@InteractPanelHeight" Min="300"  Max="1200" Color="Color.Primary">Interact Window Height</MudSlider>
                    </div>
                        <MudDynamicTabs Rounded="true" @ref="engineer_tabs" AddTab="@TabAdd" CloseTab="@TabRemove" Outlined="true">
                            @foreach (Engineer engineer in InteractEngineers)
                            {
                                string tabTitle = EngTabTitleDic[engineer.Id];
                                <MudTabPanel BadgeData=@SetPanelBadgeCount(engineer) BadgeColor=Color.Primary ID="@engineer.Id" Text="@tabTitle" Icon="@Icons.Material.Filled.Build">
                                        <MudCard Class="" Style="background:#111111; overflow-y:auto" Outlined="true">
                                            <!--This is the parent card  -->
                                        <MudPaper Style="background:#111111;" Height="@GetPanelHeight()">
                                            <MudCardContent Style="background:#111111; color:white;">
                                            
                                                @if (EngineerOutboundTaskIds.ContainsKey(engineer.Id))
                                                {
                                                 <MudExpansionPanels Style="background:#32333d; color:white;" MultiExpansion="true">
                                                @foreach (string currenttask in EngineerOutboundTaskIds[engineer.Id])
                                                {
                                                    string commandHeaderText = TaskOutputHeaderInfo[currenttask]; // gets the input based on the current task index so its always unique
                                                    EngineerTaskResult? taskResult = null;
                                                    @if (TaskOutputDic.ContainsKey(currenttask))
                                                    {
                                                        taskResult = TaskOutputDic[currenttask];
                                                    }
                                                    <InteractWindowContent currenttask="@currenttask" commandHeaderText="@commandHeaderText" engineer="@engineer" CardContent="@taskResult"></InteractWindowContent>
                                                }
                                            </MudExpansionPanels>
                                            }
                                        </MudCardContent>
                                            </MudPaper>
                                    </MudCard>
                                    @if (Settings._InteractInputMode == Interact.InteractInputMode.Classic)
                                    {
                                        <EditForm Context="EditFormContext" Model="engineer" OnValidSubmit="@Send">
                                                            <div class="d-flex mb-5">
                                                <MudAutocomplete style="background:#111111; color:white;" MaxItems="@((Interact.AutocompleteSearchShowAllItems) ? (int?)null : 10)" Strict="false" OnKeyDown="OnShowCommandHistory" @ref="mudauto" @bind-Value=@placeHolder T="string" ResetValueOnEmptyText="false" SearchFunc="@CommandSelection.SearchCommand"
                                                             Dense="true" Margin="Margin.Dense" SelectValueOnTab="true"  SelectOnClick="false" CoerceText="false" CoerceValue="true"
                                                             InputMode="InputMode.text" Variant="Variant.Outlined" Adornment="Adornment.Start" AdornmentText="[COMMAND]> " Immediate="true" Clearable="true" KeyDownPreventDefault="true" KeyUpPreventDefault="true" TextUpdateSuppression="@TextSuppersion">
                                            </MudAutocomplete>
                                 
                                            <MudButton style="background:var(--font-color);color:var(--background)" OnClick=@Send> <MudText>Send</MudText></MudButton>
                                            @if (IsEnterkey)
                                            {
                                                Task.Run(async () => await SendTask(engineer, UserInput));
                                                IsEnterkey = false;
                                            }
                                        </div>
                                        </EditForm>
                                    }
                                    else if(Settings._InteractInputMode == Interact.InteractInputMode.NoAutoComplete)
                                    {
                                        <EditForm Context="EditFormContext" Model="engineer" OnValidSubmit="@Send">
                                            <div class="d-flex mb-5">
                                                <MudTextField style="background:#111111; color:white;" OnKeyDown="OnShowCommandHistory" @bind-Value=@placeHolder T="string"
                                                    Margin="Margin.Dense"  InputMode="InputMode.text" Variant="Variant.Outlined" Adornment="Adornment.Start" AdornmentText="[COMMAND]> " Immediate="true" Clearable="true" 
                                                    TextUpdateSuppression="@TextSuppersion">
                                                </MudTextField>
                                                <MudButton style="background:var(--font-color);color:var(--background)" ButtonType="ButtonType.Submit"> <MudText>Send</MudText></MudButton>
                                                @if (IsEnterkey)
                                                {
                                                    Task.Run(async () => await SendTask(engineer, UserInput));
                                                    IsEnterkey = false;
                                                }
                                            </div>
                                            <div class="d-flex mb-5">
                                                <MudAutocomplete style="background:#111111; color:white;" @bind-Value=@placeHolder MaxItems="null" Strict="false" T="string" ResetValueOnEmptyText="true" SearchFunc="@CommandSelection.SearchCommand"
                                                     Dense="true" Margin="Margin.Dense" SelectValueOnTab="true" SelectOnClick="true" CoerceText="true"
                                                     InputMode="InputMode.text" Variant="Variant.Outlined" Label="Search Commands" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" Immediate="true" Clearable="true" TextUpdateSuppression="@TextSuppersion">
                                            </MudAutocomplete>
                                            </div>
                                        </EditForm>
                                    }
                                    else
                                    {
                                    <EditForm Context="EditFormContext" Model="engineer" OnValidSubmit="@OnCommandSelectionEnterKeyDown">
                                        <div class="d-flex mb-xl-5">
                                            <CommandSelection @ref="commandSelector" Commands="@CommandValidation.CommandList" OnEnterKeyDown="OnCommandSelectionEnterKeyDown" />

                                            <MudButton style="background:var(--font-color);color:var(--background)" OnClick=@OnCommandSelectionEnterKeyDown> <MudText>Send</MudText></MudButton>
                                            @if (IsEnterkey)
                                            {
                                                //Console.WriteLine("Enter key pressed");
                                                Task.Run(async () => await SendTask(engineer, UserInput));
                                                IsEnterkey = false;
                                            }
                                        </div>
                                    </EditForm>
                                    }
                                    <EngineerDataTable engineer="@engineer"></EngineerDataTable>
                                </MudTabPanel>
                            }
                        </MudDynamicTabs>
                    </MudTabPanel>
                    <MudTabPanel Text="Browsers" Icon="@Icons.Material.Filled.FolderOpen">
                        <FileBrowser></FileBrowser>
                    </MudTabPanel>
                    <MudTabPanel Text="Terminal" Icon="@Icons.Material.Filled.Terminal" >
                        <InteractiveTerminal></InteractiveTerminal>            
                    </MudTabPanel>
                </MudTabs>
            </MudContainer>
        </Authorized>
    </AuthorizeView>
<!--This is the Start of the GUEST READ ONLY section-->
 @*<AuthorizeView Roles="Guest">
        <Authorized>
                    <h3 class="text-center">Interact</h3>
                    <MudContainer Fixed="true">
                        <MudTabs Outlined="true">
                            <MudTabPanel Text="Engineers" Icon="@Icons.Material.Filled.Build" >
                                <XTabs Style="@setTabStyle(Settings.IsCheckedBox)" IsDraggable="true" NewTabSetActive="true" RenderMode="BlazorXTabs.Configuration.RenderMode.Partial" CloseTabs="true" OnTabRemoved="TabRemove">
                                    @foreach (Engineer engineer in InteractEngineers)
                                    {
                                        string tabTitle = EngTabTitleDic[engineer.Id];
                                        <XTab Title=@tabTitle>
                                            <MudCard Class="" Style=" background:#111111; overflow-y:auto" Outlined="true"> <!--This is the parent card  -->
                                                <MudCardContent Style="background:#111111; color:white; height:850px">
                                                    @if (EngineerOutboundTaskIds.ContainsKey(engineer.Id))
                                                    {
                                                        @foreach (string currenttask in EngineerOutboundTaskIds[engineer.Id])
                                                        {
                                                            string commandHeaderText = TaskOutputHeaderInfo[currenttask]; // gets the input based on the current task index so its always unique
                                                           bool gotStatus = TaskStatusDic.TryGetValue(currenttask, out EngTaskStatus status);
                                                           if(gotStatus == false)
                                                            {
                                                                status = EngTaskStatus.NONE;
                                                            }
                                                            bool gotContent = TaskOutputDic.TryGetValue(currenttask, out EngineerTaskResponse cardContent);
                                                            if (gotContent == false)
                                                            {
                                                                cardContent = null;
                                                            }
                                                            bool gotTask =  TaskInputDic.TryGetValue(currenttask, out EngineerTask task);
                                                            if(gotTask == false)
                                                            {
                                                                task = null;
                                                            }
                                                            <MudExpansionPanels Style="background:#32333d; color:white;" MultiExpansion="true">
                                                            @if(RenderedFinalFormDic.Contains(currenttask))
                                                                {}
                                                            else
                                                            {
                                                                <InteractWindowContent HeaderContent="@commandHeaderText" engTaskStatus="@status" engineer="@engineer" CardContent="@cardContent" EngTask="@task"></InteractWindowContent>
                                                            }
                                                                <MudExpansionPanel IsExpandedChanged="(e)=>ExpandedChanged(e,engineer.Id,currenttask)"  style="background:#32333d; color:white;">
                                                                    <TitleContent>
                                                                        @if (PickedUpTasks.Contains(currenttask) && !(EngineerReturnedTaskIds.Values.Any(x => x.Contains(currenttask))))
                                                                        {
                                                                            <div class="d-flex">
                                                                                <MudProgressCircular Size="Size.Small" Color="Color.Primary" Indeterminate="true" Class="mr-3" />
                                                                                <MudIconButton Icon="@Icons.Material.Filled.Cancel" Size="Size.Small" Color="Color.Error" OnClick="() =>CancelTask(currenttask,engineer.Id)"></MudIconButton>
                                                                                <MudText>@commandHeaderText</MudText>                                                   
                                                                            </div>
                                                                        }
                                                                        else if (EngineerReturnedTaskIds.Values.Any(x => x.Contains(currenttask) && TaskStatusDic.ContainsKey(currenttask)))
                                                                        {
                                                                            if (TaskStatusDic[currenttask] == EngTaskStatus.Running)
                                                                            {
                                                                                <div class="d-flex">
                                                                                    <MudProgressCircular Size="Size.Small" Color="Color.Primary" Indeterminate="true" Class="mr-3" />
                                                                                    <MudIconButton Icon="@Icons.Material.Filled.Cancel" Size="Size.Small" Color="Color.Error" OnClick="() =>CancelTask(currenttask,engineer.Id)"></MudIconButton>
                                                                                    <MudText>@commandHeaderText</MudText>
        
                                                                                </div>
                                                                            }
                                                                            else
                                                                            {
                                                                                <div class="d-flex">
                                                                                    <MudIcon Icon=@setIcon(currenttask) Color=@SetColor(currenttask) class="mr-3"></MudIcon>
                                                                                    <MudText>@commandHeaderText</MudText>
                                                                                </div>
                                                                            }
                                                                        }
                                                                        else
                                                                        {
                                                                            <div class="d-flex">
                                                                                <MudIcon Icon=@setIcon(currenttask) Color=@SetColor(currenttask) class="mr-3"></MudIcon>
                                                                                <MudText>@commandHeaderText</MudText>
                                                                            </div>
                                                                        }
                                        
                                                                    </TitleContent>
                                                                    <ChildContent>
                                                                        <MudCard Class="" Style="background:var(--background);" Outlined="true"> <!--This is the per input and output card-->
                                                                            <MudCardContent Style="background:#111111; color:white; white-space:pre-wrap;">
                                        
                                                                                @if (TaskOutputDic.ContainsKey(currenttask))
                                                                                {
                                                                                    <!-- <MudText>output for components go here atm thats ls command, ps command, ipconfig, anything that can use a table</MudText> -->
                                                                                    // List<string> output = TaskOutputDic[currenttask];
                                                                                @if(TaskOutputDic[currenttask] !=null)
                                                                                {
                                                                                    @if (TaskOutputDic[currenttask].Result != null)
                                                                                    {
                                                                                        @if (TaskInputDic[currenttask].Command == "ls" && TaskStatusDic[currenttask] == EngTaskStatus.Complete)
                                                                                        {
                                                                                            TaskInputDic[currenttask].Arguments.TryGetValue("/path", out string pathValue);
                                                                                            <HardHatC2Client.Components.DirectoryListingTable Outputs="@TaskOutputDic[currenttask].Result"/>
                                                                                            if (pathValue != null)
                                                                                            {
                                                                                                pathValue = pathValue.TrimStart(' ').TrimEnd(' ');
                                                                                                FileBrowser.AddContent(engineer.Hostname, pathValue, TaskOutputDic[currenttask].Result.Deserialize<List<FileSystemItem>>());
                                                                                            }
                                                                                        }
                                                                                        else if (TaskInputDic[currenttask].Command == "ps" && TaskStatusDic[currenttask] == EngTaskStatus.Complete)
                                                                                        {
                                                                                            var result = TaskOutputDic[currenttask].Result.Deserialize<string>().Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList();
                                                                                            <HardHatC2Client.Components.ProcessListingTable Outputs="@result"/>
                                                                                        }
                                                                                        else if (TaskInputDic[currenttask].Command == "getprivs" && TaskStatusDic[currenttask] == EngTaskStatus.Complete)
                                                                                        {
                                                                                            var result = TaskOutputDic[currenttask].Result.Deserialize<string>().Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList();
                                                                                            <HardHatC2Client.Components.GetPrivsTable Outputs="@result"/>
                                                                                        }
                                                                                        else if (TaskInputDic[currenttask].Command == "print-env" && TaskStatusDic[currenttask] == EngTaskStatus.Complete)
                                                                                        {
                                                                                            var result = TaskOutputDic[currenttask].Result.Deserialize<string>().Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList();
                                                                                                <HardHatC2Client.Components.PrintEnvTable Outputs="@result"/>
                                                                                            }
                                                                                        else if (TaskInputDic[currenttask].Command.Equals("help",StringComparison.CurrentCultureIgnoreCase))
                                                                                        {
                                                                                            <HelpTable Outputs="TaskOutputDic[currenttask].Result"></HelpTable> 
                                                                                        }
                                                                                        else if (ParsedCommandOutputDic.ContainsKey(currenttask) && TaskStatusDic[currenttask] == EngTaskStatus.Complete)
                                                                                        {
                                                                                            <MudSwitch @bind-Checked="@IsTableView" Label="Toggle Table View" Color="Color.Success"/>
                                                                                            if (IsTableView == true)
                                                                                            {
                                                                                                <HardHatC2Client.Components.AutpParsedCommandTable Outputs="ParsedCommandOutputDic[currenttask]"></HardHatC2Client.Components.AutpParsedCommandTable>
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                                var output = TaskOutputDic[currenttask].Result.Deserialize<string>();
                                                                                                <MudText Class="text-break" style="font-family:Courier New, Courier, monospace">@output</MudText>
                                                                                            }
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                            var output = TaskOutputDic[currenttask].Result.Deserialize<string>();
                                                                                            <MudText Class="text-break" style="font-family:Courier New, Courier, monospace">@output</MudText>
                                                                                        }
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        <MudText Typo="Typo.body2">No output yet</MudText>
                                                                                    }
                                                                                }
                                                                                }            
                                                                                else if (!TaskOutputDic.ContainsKey(currenttask))
                                                                                {
                                                                                    <MudText Typo="Typo.body2">No output yet</MudText>
                                                                                }
         
                                                                            </MudCardContent>
                                                                        </MudCard>  
                                                                    </ChildContent>
                                                                </MudExpansionPanel><!--This is the end of per input and output card -->   
                                                            </MudExpansionPanels>
                                                        }
                                                    }
                                                </MudCardContent>
                                            </MudCard>
                                            <EditForm Context="EditFormContext" Model="engineer">
                                                <div class="d-flex mb-xl-5">
                        
                                                    <MudAutocomplete Disabled="true"  @ref="mudauto" @bind-Value=@placeHolder T="string" ResetValueOnEmptyText="true"
                                                                     Dense="true" Margin="Margin.Dense" SelectValueOnTab="true"  SelectOnClick="false" CoerceText="false" CoerceValue="true"
                                                                     InputMode="InputMode.text" Variant="Variant.Text" Adornment="Adornment.Start" AdornmentText="[ENGINEER]> " Immediate="true" Clearable="true" KeyDownPreventDefault="true" KeyUpPreventDefault="true" TextUpdateSuppression="@TextSuppersion">
                                                    </MudAutocomplete>
                                         
                                                    <MudButton Disabled="true" style="background:var(--font-color);color:var(--background)" > <MudText>Send</MudText></MudButton>
                                                </div>
                                            </EditForm>
                                            <EngineerDataTable engineer="@engineer"></EngineerDataTable>
                                        </XTab>
                                    }
                                </XTabs>
                            </MudTabPanel>
                            <MudTabPanel Text="Browsers" Icon="@Icons.Material.Filled.FolderOpen">
                                <FileBrowser></FileBrowser>
                            </MudTabPanel>
                            <MudTabPanel Text="Terminal" Icon="@Icons.Material.Filled.Terminal" >
                                <InteractiveTerminal></InteractiveTerminal>            
                            </MudTabPanel>
                        </MudTabs>
                    </MudContainer>
                </Authorized>
</AuthorizeView>*@
<AuthorizeView Roles="Operator,TeamLead,Guest,Administrator">
    <NotAuthorized>
        <h1 class="text-center">Not Authorized</h1>
        <HardHatC2Client.Components.UnAuthorizedDialogBox></HardHatC2Client.Components.UnAuthorizedDialogBox>
    </NotAuthorized>
</AuthorizeView>
</CascadingAuthenticationState>

<style>
    .my-custom-class {
        backdrop-filter: blur(10px);
    }
</style>

@code {
    [Inject] 
    private IDialogService DialogService { get; set; }
    private static IDialogService _dialogService { get; set; }
    [Inject]
    private static RestClient _restClient { get; set; }
    [Inject]
    private static NavigationManager Nav { get; set; }
    [Inject]
    public ILocalStorageService LocalStorage { get; set; }
    internal static Dictionary<string, List<string>> EngineerOutboundTaskIds = new(); // key is engineer id, value is list of task ids
    internal static Dictionary<string,EngineerTask> TaskInputDic = new(); // first key is taskId and value is the userInput for commands


    internal static Dictionary<string, List<string>> EngineerReturnedTaskIds = new(); // key is engineer id, value is list of task ids
    internal static Dictionary<string,EngineerTaskResult> TaskOutputDic = new(); // first key is taskID and value is the output from the task
    internal static Dictionary<string, EngTaskStatus> TaskStatusDic = new(); // first key is taskID and value is the status of the task

    internal static Dictionary<string, string> TaskOutputHeaderInfo = new(); // first key is taskID and value is the task output header
    public static List<Engineer> InteractEngineers = new(); // list of the engineerrs the user has added for interaction 

    public static Dictionary<string, string> EngTabTitleDic = new(); // key is engineer id, value is the tab title

    public static Dictionary<string, List<string>> ParsedCommandOutputDic = new(); // key is task id, value is a dictionary of properties containing the property name and value
    public static Dictionary<string, int> LinesParsedCommandsDic = new();
    public static List<string> RenderedFinalFormDic = new List<string>();

    public static List<string> PickedUpTasks = new();

    public static Dictionary<string,bool> PanelExpandedOnce = new(); // key is task id, value is a bool indicating if the panel has been expanded once

    private static string UserInput { get; set;}
    private string placeHolder = null;
    private bool IsEnterkey { get; set; } = false;
    //private static Command userCommand = new Command();
    private MudAutocomplete<string> mudauto { get; set; }
    private Engineer currentEng = null;
    private static List<string> PreviousCommands = new();
    private string selectedHistoryCommand = null;
    private static int HistoryIndex = -1;

    private string icon = Icons.Material.Filled.CheckCircle;
    public static bool TextSuppersion = true;
    private static bool IsTableView = true;
    public static bool FirstRender = true;
    private static bool Initialized = false;
    private static bool removeContentSwitch  { get; set; }

    private static Stopwatch stopwatch = new Stopwatch();
    private static Stopwatch stopwatch2 = new Stopwatch();

    private static string OutputOneStringTest = "";
    //create a delegate that we can use to invoke statehaschanged 
    public delegate Task OnStateChangeDelegate();
    public static OnStateChangeDelegate OnStateChange;
    public delegate Task OnWindowInteractSubmission();
    public static OnWindowInteractSubmission _onWindowInteractSubmission;
    private static DateTime? LastRefresh { get; set; } = null;
    public static int InteractPanelHeight { get; set; } = 850;
    private static Dictionary<string,MudExpansionPanel> Interact_ExpansionPanels = new(); //key is the task id since those are unique per panel anyway.
    private static List<string>CancelTaskNumbersToWatch = new List<string>();
    private static CommandItem SelectedCommandItem { get; set; }
    private static List<string> CommandsOrOptions = new List<string>();
    private CommandSelection commandSelector;
    public static bool AutocompleteSearchShowAllItems { get; set; } = false;
    public static MudTabs engineer_tabs;
    public static string interactedEngineerId = "";
    public static bool interactedEngIdUpdated = false;

    public static List<string> contextChangingCommands = new List<string>() {"getsystem", "make_token", "steal_token", "rev2self" };

    public enum InteractInputMode
    {
        Classic,
        Inline,
        Modal_Window,
        NoAutoComplete
    }

    private string setTabStyle(bool IsDark)
    {
        if(IsDark)
        {
            return "background:#32333d; color:white;";
        }
        return "background:white; color:black;";  
    }

    //set the icon and color for commands 
    private string setIcon(string currenttask)
    {
        if (TaskStatusDic.ContainsKey(currenttask))
        {
            if (TaskStatusDic[currenttask] == EngTaskStatus.Complete)
            {
                return Icons.Filled.CheckCircle;
            }
            else if (TaskStatusDic[currenttask] == EngTaskStatus.Cancelled)
            {
                return Icons.Filled.StopCircle;
            }
            else if (TaskStatusDic[currenttask] == EngTaskStatus.Failed)
            {
                return Icons.Filled.SmsFailed;
            }
            else if (TaskStatusDic[currenttask] == EngTaskStatus.FailedWithWarnings)
            {
                return Icons.Filled.Warning;
            }
            else if (TaskStatusDic[currenttask] == EngTaskStatus.CompleteWithErrors)
            {
                return Icons.Filled.CheckCircle;
            }
            else
            {
                return Icons.Filled.Info;
            }
        }
        else
        {
            return Icons.Filled.Info;
        }
    }

    private Color SetColor(string currenttask)
    {
        if (TaskStatusDic.ContainsKey(currenttask))
        {
            if (TaskStatusDic[currenttask] == EngTaskStatus.Complete)
            {
                return Color.Success;
            }
            else if (TaskStatusDic[currenttask] == EngTaskStatus.Cancelled)
            {
                return Color.Secondary;
            }
            else if (TaskStatusDic[currenttask] == EngTaskStatus.Failed)
            {
                return Color.Error;
            }
            else if (TaskStatusDic[currenttask] == EngTaskStatus.FailedWithWarnings)
            {
                return Color.Warning;
            }
            else if (TaskStatusDic[currenttask] == EngTaskStatus.CompleteWithErrors)
            {
                return Color.Warning;
            }
            else
            {
                return Color.Info;
            }
        }
        else
        {
            return Color.Info;
        }
    }

    public static string SetPanelBadgeCount(Engineer Engineer)
    {
        int count = 0;
        if (EngineerReturnedTaskIds.ContainsKey(Engineer.Id))
        {
            //get the task ids for this engineer
            if (EngineerReturnedTaskIds.TryGetValue(Engineer.Id, out List<string> taskids))
            {
                //for each taskid not in the ExpandedOnce Dict add to the count 
                foreach (string taskid in taskids)
                {
                    if (!PanelExpandedOnce.ContainsKey(taskid) || PanelExpandedOnce[taskid] == false)
                    {
                        count++;
                    }
                }
                if (count == 0)
                {
                    return "";
                }
                OnStateChange();
                return count.ToString();
            }
            return "";
        }
        return "";
    }

    public static string GetPanelHeight()
    {
        return InteractPanelHeight.ToString() + "px";
    }

    public static async Task AddTaskToPickedUpList(string taskid)
    {
        if (!PickedUpTasks.Contains(taskid))
        {
            PickedUpTasks.Add(taskid);
        }
        if (OnStateChange is not null)
        {
            await OnStateChange();
        }
    }


    public async Task ImplementOnStateChangeEvent()
    {
        if (LastRefresh == null)
        {
            LastRefresh = DateTime.Now;
            await InvokeAsync(StateHasChanged);
        }
        else
        {
            // if more then 500 ms has passed since the last refresh then refresh the page
            if (DateTime.Now.Subtract(LastRefresh.Value).TotalMilliseconds > 500)
            {
                LastRefresh = DateTime.Now;
                await Task.Delay(100);
                await InvokeAsync(StateHasChanged);
            }
        }
    }


    private async Task UpdateUserInput()
    {
        if (commandSelector.SelectedCommandItem != null)
        {
            var selectedCommand = commandSelector.SelectedCommandItem.Name;

            // Filter out keys with empty values
            var keyValuePairs = commandSelector.keyValue.Where(kvp => !string.IsNullOrEmpty(kvp.Value));

            // Build the command string with key-value pairs
            var commandString = selectedCommand + " " + string.Join(" ", keyValuePairs.Select(kvp => $"{kvp.Key} {kvp.Value}"));
            placeHolder = commandString.Trim();
            //Console.WriteLine($"Command string should be {placeHolder}");
        }
    }

    private async Task OnCommandSelectionEnterKeyDown()
    {
        await UpdateUserInput();
        await Send();
    }

    private void OnTextChanged(string text)
    {
        placeHolder = text;
        // Update the list of content based on the selected command
    }

    public async Task Send()
    {
        if (!String.IsNullOrWhiteSpace(placeHolder))
        {
            UserInput = placeHolder;
            TextSuppersion = false; //allows text box to be updated
            placeHolder = "";      // sets text back to empty
            IsEnterkey = true;
            await Task.Delay(2);
            TextSuppersion = true; // reset so textbox can be typed in without autoclearing until submission

            if (OnStateChange is not null)
            {
                await OnStateChange();
            }
            //if any of the strings in PreviousCommands matches UserInput then do not add it
            if (!PreviousCommands.Contains(UserInput))
            {
                PreviousCommands.Insert(0,UserInput);
            }
            HistoryIndex = -1;
        }
    }




    public static async Task UpdateOutGoingTaskDic(string engineerId,string taskId, string commandHeader)
    {
        //if engineer.Id is not already a key in the EngineerUniqueInputDictionary make it a new list with the name InputList plus the engineer.Id at the end
        if (!EngineerOutboundTaskIds.ContainsKey(engineerId))
        {
            EngineerOutboundTaskIds.Add(engineerId, new List<string>());
        }
        if(EngineerOutboundTaskIds.ContainsKey(engineerId))
        {
            //add the taskid to the list of taskids for the engineerid and pass the taskId to the sendTask function
            if (!EngineerOutboundTaskIds[engineerId].Contains(taskId))
            {
                EngineerOutboundTaskIds[engineerId].Add(taskId);
                //if taskId is not in the TaskOutputHeaderInfo then add it with commandHeaderText as the value
                if (!TaskOutputHeaderInfo.ContainsKey(taskId))
                {
                    TaskOutputHeaderInfo.Add(taskId, commandHeader);
                }
            }
        }
        if (OnStateChange is not null)
        {
            await OnStateChange();
        }
    }


    //new task to getExistingTaskInfo 
    public static async Task GetExistingTaskInfo(Dictionary<string,List<EngineerTask>> PreviousTasks)
    {
        //pervoius tasks just holds the task id and the header text 
        //pull out the tasks from the previous tasks dictionary and add them to the EngineerOutboundTaskIds dictionary and add the task.Command and Task.Args to the TaskInputDic with Task.Id as the key
        foreach (KeyValuePair<string, List<EngineerTask>> kvp in PreviousTasks)
        {
            foreach (EngineerTask task in kvp.Value)
            {
                //var args = task.Arguments is null ? "" : string.Join(" ", task.Arguments.Select(kvp => $"{kvp.Key} {kvp.Value}"));
                if(!TaskInputDic.ContainsKey(task.Id))
                {
                    //the split should pull out the command only so engineer instructed to ls /path c:\users\ would be come ls /path c:\users\ , then split on the first non leading space so becomes ls
                    EngineerTask temp = new EngineerTask() {Id = task.Id, Command= task.Command.Split("to")[1].TrimStart().Split(' ')[0], Arguments = task.Arguments};
                    TaskInputDic.Add(temp.Id, temp);
                }
                await UpdateOutGoingTaskDic(kvp.Key, task.Id, task.Command);
            }
        }
        if (OnStateChange is not null)
        {
            await OnStateChange();
        }
    }

    public async Task SendTask(Engineer engineer, string command)
    {
        try
        {
            //parse input for aliases 
            command = ParseInputForAliases(command,out string aliasParseError);
            if (!string.IsNullOrWhiteSpace(aliasParseError))
            {
                Engineers.ShowErrorToast(aliasParseError);
                return;
            }


            Console.WriteLine("Starting send Task");
            string currentTaskId = Guid.NewGuid().ToString();
            var createObject = new TaskEngineerRequest();
            createObject.Command = command.Split(' ')[0];
            //if command is help then run help and return
            if (createObject.Command.Trim().Equals("help", StringComparison.CurrentCultureIgnoreCase))
            {
                Dictionary<string, string> helpDiction = new Dictionary<string, string>();
                string commandCheck = "";
                string helpCommandheader = "";
                if (command.Split(' ').Length > 2)
                {
                    commandCheck = command.Split(' ')[2];
                    helpCommandheader = $"({DateTime.UtcNow}) Engineer instructed to {createObject.Command} {command.Split(' ')[1]} {command.Split(' ')[2]}\n";
                }
                else
                {
                    helpCommandheader = $"({DateTime.UtcNow}) Engineer instructed to {createObject.Command}\n";
                }
                if (!string.IsNullOrWhiteSpace(commandCheck))
                {
                    helpDiction.Add("/command", commandCheck);
                }
                List<Help.HelpMenuItem> helpMenu = Help.DisplayHelp(helpDiction);


                if (!TaskOutputDic.ContainsKey(currentTaskId))
                {
                    if (!TaskInputDic.ContainsKey(currentTaskId))
                    {
                        TaskInputDic.Add(currentTaskId, new EngineerTask { Id = currentTaskId, Command = createObject.Command, Arguments = helpDiction, File = null });
                    }
                    await UpdateOutGoingTaskDic(engineer.Id, currentTaskId, helpCommandheader);
                    var taskResponse = new EngineerTaskResult();
                    taskResponse.Id = currentTaskId;
                    taskResponse.Status = EngTaskStatus.Complete;
                    taskResponse.ResponseType = TaskResponseType.HelpMenuItem;
                    taskResponse.ResultObject = helpMenu;
                    TaskOutputDic.Add(currentTaskId, taskResponse);
                    if (!TaskStatusDic.ContainsKey(currentTaskId))
                    {
                        TaskStatusDic.Add(currentTaskId, (EngTaskStatus)taskResponse.Status);
                    }
                }
                return; //return here because help command does not need to be sent to the engineers
            }

            Dictionary<string, string> commandargs = new Dictionary<string, string>();
            string error = null;

            //find the command in the helpMenuItems list that matches the command name
            HelpMenuItem helpMenuItem = menuItems.First(x => x.Name.Equals(createObject.Command, StringComparison.OrdinalIgnoreCase));
            if (helpMenuItem != null)
            {
                if (helpMenuItem.Opsec == HelpMenuItem.OpsecStatus.Blocked)
                {
                    error = "Command is blocked by teamlead";
                }
                else if (helpMenuItem.Opsec == HelpMenuItem.OpsecStatus.High)
                {
                    //we want to spawn a message box to get a yes or a no here ,if the user says no then return false, if the user says yes then continue
                    bool? result = null;
                    await InvokeAsync( async () => 
                    {
                        result = await _dialogService.ShowMessageBox("Opsec Warning", "Command is set to High opsec danger level, are you sure you want to execute?", yesText: "Fire Away!", cancelText: "Cancel");
                    });
                    //bool? result =  messageBoxTask.Result;
                    if (result is null || result == false)
                    {
                        error = "Command Cancelled by user";
                    }
                    else
                    {
                        CommandValidation.ValidateCommand(command, out commandargs, out error);
                    }
                }
                else
                {
                    CommandValidation.ValidateCommand(command, out commandargs, out error);
                }
            }
            else
            {
                CommandValidation.ValidateCommand(command, out commandargs, out error);
            }
            if (error != null)
            {
                Engineers.ShowErrorToast(error);
                return;
            }

            //check if createObject.Command is one of the postex that make a new implant 
            if(ImplantCreation.PostExCommandsThatSpawnNewImp.Contains(createObject.Command,StringComparer.InvariantCultureIgnoreCase))
            {
                var diag_options = new DialogOptions { ClassBackground = "dialog-blur-class", MaxWidth = MaxWidth.Large, FullWidth = true, DisableBackdropClick = true };
                //invoke async needs to used to trigger the render to work correctly from inside c# code
                await InvokeAsync( async () => 
                {
                    var diagTask = DialogService.Show<ImplantCreation_Dialog>("Create Implant for PostEx Command",diag_options);
                    var result = await diagTask.Result;
                    if (result.Canceled)
                    {
                        return;
                    }
                    else
                    {
                        createObject.TaskingExtras.Add("PostExImplantRequest", ImplantCreation_Dialog.PostExSpawnRequest.Serialise());
                    }
                });
            }

            //if commandargs contains a /local key we should update the file content 
            if (commandargs.ContainsKey("/local"))
            {
                // check each command arg to see if it contains a file path
                foreach (KeyValuePair<string, string> kvp in commandargs)
                {
                    if (File.Exists(kvp.Value))
                    {
                        createObject.File = File.ReadAllBytes(kvp.Value);
                    }
                }
                if(!(createObject.File.Length > 0))
                {
                    Engineers.ShowErrorToast("/local flag used but no matching file found on client");
                    return;
                }
            }
            createObject.Arguments = commandargs;

            //assign the task id to the task
            createObject.taskID = currentTaskId;

            //if arguments contains /method as a key then if the value is sync set the IsBlocking parameter to true if its async set it to false, if the key is not present set it to false
            if (createObject.Arguments.ContainsKey("/method"))
            {
                //createObject.Arguments["/method"] = createObject.Arguments["/method"];
                if (createObject.Arguments["/method"].Equals("sync", StringComparison.CurrentCultureIgnoreCase))
                {
                    createObject.IsBlocking = true;
                }
                else if (createObject.Arguments["/method"].Equals("async", StringComparison.CurrentCultureIgnoreCase))
                {
                    createObject.IsBlocking = false;
                }
                else
                {
                    createObject.IsBlocking = false;
                }
            }
            else
            {
                createObject.IsBlocking = false;
            }

            //update the input dictionary with the new task
            if (TaskInputDic.ContainsKey(createObject.taskID))
            {
                TaskInputDic[createObject.taskID] = new EngineerTask { Id = createObject.taskID, Command = createObject.Command, Arguments = createObject.Arguments, File = null };
            }
            else if (!TaskInputDic.ContainsKey(createObject.taskID))
            {
                TaskInputDic.Add(createObject.taskID, new EngineerTask { Id = createObject.taskID, Command = createObject.Command, Arguments = createObject.Arguments, File = null });
            }
            if (OnStateChange is not null)
            {
                await OnStateChange();
            }

            //update the local outgoing header to make it apear faster upon submit
            var args = createObject.Arguments is null ? "" : string.Join(" ", createObject.Arguments.Select(kvp => $"{kvp.Key} {kvp.Value}"));
            string Commandheader = $"({DateTime.UtcNow}) Engineer instructed to {createObject.Command + " " + args}\n";
            Task.Run(async () => await UpdateOutGoingTaskDic(engineer.Id, currentTaskId, Commandheader));
            if (OnStateChange is not null)
            {
                await OnStateChange();
            }

            //send the task to the server
            string resource = $"/engineers/{engineer.Id}";
            var request = new RestRequest(resource, Method.Post);
            request.AddJsonBody(createObject);
            request.OnBeforeDeserialization = (resp =>
            {
                //Console.WriteLine(resp.Content);
            });
            _ = await Task.Run(() => _restClient.PostAsync(request));
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            Console.WriteLine(ex.StackTrace);
        }
    }
    // end of send task function


    public static async Task ExpandedChanged(bool IsChanged, string engineerId, string taskId)
    {
        try
        {
            if (!PanelExpandedOnce.ContainsKey(taskId))
            {
                PanelExpandedOnce.Add(taskId, true);
                string username = Login.SignedInUser;
                HardHatHubClient._hub.UpdateTaskResponseSeenNotif(username,taskId,engineerId);
            }
            else if (PanelExpandedOnce[taskId] == false)
            {
                PanelExpandedOnce[taskId] = true;
                string username = Login.SignedInUser;
                HardHatHubClient._hub.UpdateTaskResponseSeenNotif(username, taskId, engineerId);
            }

            if (removeContentSwitch)
            {
                //check if task command is help if so skip 
                if (TaskInputDic[taskId].Command.Equals("help", StringComparison.CurrentCultureIgnoreCase))
                {
                    return;
                }

                if (IsChanged)
                {
                    if (!TaskOutputDic.ContainsKey(taskId))
                    {
                        var taskInfo = await GetTaskResults(engineerId, taskId);
                        TaskOutputDic.Add(taskId, taskInfo);
                    }
                    if (OnStateChange is not null)
                    {
                        await OnStateChange();
                    }
                }
                else
                {
                    TaskOutputDic.Remove(taskId);
                    //this should off load this to another thread so the panel can close faster
                    GC.Collect();
                    //GC.WaitForPendingFinalizers();
                }
            }


        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
            Console.WriteLine(e.StackTrace);
        }

    }

    public static string CleanString(string input)
    {
        // Remove any double quotes surrounding the input string
        string cleanedInput = input.Trim('\"');
        // Split the cleaned input string into lines
        string[] lines = cleanedInput.Split(Environment.NewLine);
        // Rejoin the lines with a newline character and return the result
        return string.Join(Environment.NewLine, lines);
    }

    private Task TabRemove(MudTabPanel tab)
    {
        //find the engineer where its ProcessId@Address matches the tabs Title and remove it 
        var engineer = InteractEngineers.FirstOrDefault(x => x.Id == tab.ID);
        InteractEngineers.Remove(engineer);
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task TabAdd()
    {
        //cause a mud popup where the user can select to add engineers from the engineer table that are not yet interacted with 
        var options = new DialogOptions { ClassBackground = "my-custom-class", MaxWidth = MaxWidth.Medium, FullWidth = true, DisableBackdropClick = true };
        var dialog = DialogService.Show<ImplantTablePopup>("Add Implants for Interaction", options);

        var result = await dialog.Result;
        if(!result.Canceled)
        {
            //result.Data should be a list of engineer objects
            List<Engineer> newEngineers = result.Data as List<Engineer>;
            foreach(Engineer eng in newEngineers)
            {
                Engineers.AddImplantToInteract(eng);
            }
        }
        return;
    }

    //parse input for Aliases and replace them with the correct command
    public static string ParseInputForAliases(string input, out string error)
    {
        //if input contains any strings that start with $hh_ find the alias and replace it with the alias value
        //if the alias is not found return an error
        error = "";
        List<string> inputArray = input.Split(" ").ToList();
        foreach(string inputPart in inputArray)
        {
            if (inputPart.Contains("$hh_"))
            {
                //find the alias in the alias list
                AliasEdit_Dialog.Alias alias = AliasEdit_Dialog.inputAlises.FirstOrDefault(x => x.Name == inputPart);
                if(alias is null)
                {
                    error = $"Alias {inputPart} not found";
                    return input;
                }
                else
                {
                    //replace the alias with the alias value
                    input = input.Replace(inputPart, alias.Value);
                    //check if the alias value contains any other aliases
                    if (alias.Value.Contains("$hh_"))
                    {
                        //if it does call this function again to replace the alias
                        input = ParseInputForAliases(input, out error);
                    }
                }
            }
        }
        return input;
    }

    public async Task ShowAliasDialog()
    {
        var options = new DialogOptions { ClassBackground = "my-custom-class", MaxWidth = MaxWidth.Medium, FullWidth = true, DisableBackdropClick = true };
        var dialog = DialogService.Show<AliasEdit_Dialog>("Create Command Input Aliases", options);
        var result = await dialog.Result;
    }

    //called by signalR when a new task response comes in 
    public static async Task UpdateTaskResponse(string engineerid, List<string> returnedTaskids)
    {
        // for each returnedtaskid add it to the TaskIdQueue for the engineerid and then set the GotTaskResponse to true and set the taskid to the first taskid in the queue and execute GetTaskResults
        if (returnedTaskids != null)
        {
            // if the engineerid is not in the dictionary add it
            if (!EngineerReturnedTaskIds.ContainsKey(engineerid))
            {
                EngineerReturnedTaskIds.Add(engineerid, new List<string>());
            }
            // using the returned id list call GetTaskResults for each taskid and add the results to the EngineerTaskOutputDic
            foreach (string taskid in returnedTaskids)
            {
                if (!TaskOutputDic.ContainsKey(taskid))
                {
                    TaskOutputDic.Add(taskid, null);
                }
                var tempTaskResults  = await GetTaskResults(engineerid, taskid);
                //if task.command equals cancelTask then dont add ito the taskoutPutDic just display a toast
                if (tempTaskResults != null)
                {
                    if (CancelTaskNumbersToWatch.Contains(tempTaskResults.Id))
                    {
                        if (tempTaskResults.Status == EngTaskStatus.Complete)
                        {
                            Engineers.ShowSuccessToast((string)tempTaskResults.ResultObject);
                        }
                        else if (tempTaskResults.Status == EngTaskStatus.Failed)
                        {
                            Engineers.ShowErrorToast((string)tempTaskResults.ResultObject);
                        }
                    }
                }
                TaskOutputDic[taskid] = tempTaskResults;
                if (tempTaskResults != null && tempTaskResults.UsersThatHaveReadResult != null)
                {
                    foreach (string username in tempTaskResults.UsersThatHaveReadResult)
                    {
                        //if username matches logged in user then check if the panelexpandedonce contains the taskid if not then add it as false 
                        if (username == Login.SignedInUser)
                        {
                            //basically this says the teamserver has a record of this task id being seen by the user so we can set the panel as being expanded before to prevent repeated notifications
                            if (!PanelExpandedOnce.ContainsKey(taskid))
                            {
                                PanelExpandedOnce.Add(taskid, true);
                            }
                            else
                            {
                                PanelExpandedOnce[taskid] = true;
                            }
                        }
                    }
                }

                //if TaskOutputDic[taskid] == No Output then remove the taskid from the TaskOutputDic
                if (TaskOutputDic[taskid] != null)
                {
                    if (TaskOutputDic[taskid].ResultObject == null)
                    {
                        TaskOutputDic.Remove(taskid);
                    }
                }
                //check the taskid against the taskInputDic to see if its an ls command if so then we can send data to the file browser component
                if (TaskInputDic.ContainsKey(taskid))
                {
                    if (TaskInputDic[taskid].Command == "ls")
                    {
                        if (TaskOutputDic[taskid] != null)
                        {
                            if (TaskOutputDic[taskid].ResultObject == null)
                            {
                                TaskOutputDic[taskid] = null;
                            }
                            else
                            {
                                //send the output to the file browser component
                                //find the engineer object this task belongs to
                                Engineer engineer = null;
                                foreach (Engineer eng in Engineers.EngineerList)
                                {
                                    if (eng.Id == engineerid)
                                    {
                                        engineer = eng;
                                    }
                                }
                                //check the task status to see if it was successful
                                if (TaskStatusDic[taskid] == EngTaskStatus.Complete)
                                {
                                    bool gotOutput = TaskInputDic[taskid].Arguments.TryGetValue("/path", out string pathValue);
                                    if (gotOutput)
                                    {
                                        pathValue = pathValue.TrimStart(' ').TrimEnd(' ');
                                        FileBrowser.AddContent(engineer.Hostname, pathValue, TaskOutputDic[taskid].ResultObject as List<FileSystemItem>);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (OnStateChange is not null)
        {
            await OnStateChange();
        }
    }

    public static async Task<EngineerTaskResult> GetTaskResults(string engineerId, string taskid)
    {
        try
        {
            if (_restClient is not null)
            {
                //gets the task results from the server
                string resource = $"/engineers/{engineerId}/tasks/{taskid}";
                var request = new RestRequest(resource, Method.Get);
                // var requestResponse = await _restClient.GetAsync<EngineerTaskResponse>(request);
                var requestResponse = await _restClient.GetAsync<EngineerTaskResult>(request);
                EngineerTaskResult taskResult = new EngineerTaskResult();
                if (requestResponse != null && requestResponse.Result != null)
                {
                    switch (requestResponse.ResponseType)
                    {
                        case TaskResponseType.String:
                            {
                                taskResult = new EngineerTaskResult
                                {
                                    Id = requestResponse.Id,
                                    EngineerId = requestResponse.EngineerId,
                                    Command = requestResponse.Command,
                                    UsersThatHaveReadResult = requestResponse.UsersThatHaveReadResult,
                                    ResultObject = requestResponse.Result.Deserialize<MessageData>()?.Message.RemoveDoubleEmptyLines() ?? string.Empty, // should help to ensure when only a string comes back it is still formatted like true json.
                                    Status = (EngTaskStatus)requestResponse.Status,
                                    ResponseType = (TaskResponseType)requestResponse.ResponseType,
                                };
                                break;
                            }
                        case TaskResponseType.FileSystemItem:
                            {
                                taskResult = new EngineerTaskResult
                                {
                                    Id = taskid,
                                    EngineerId = requestResponse.EngineerId,
                                    Command = requestResponse.Command,
                                    UsersThatHaveReadResult = requestResponse.UsersThatHaveReadResult,
                                    ResultObject = requestResponse.Result.Deserialize<List<FileSystemItem>>(),
                                    Status = (EngTaskStatus)requestResponse.Status,
                                    ResponseType = (TaskResponseType)requestResponse.ResponseType,
                                };
                                break;
                            }
                        case TaskResponseType.ProcessItem:
                            {
                                taskResult = new EngineerTaskResult
                                    {
                                        Id = taskid,
                                        EngineerId = requestResponse.EngineerId,
                                        Command = requestResponse.Command,
                                        UsersThatHaveReadResult = requestResponse.UsersThatHaveReadResult,
                                        ResultObject = requestResponse.Result.Deserialize<List<ProcessItem>>(),
                                        Status = (EngTaskStatus)requestResponse.Status,
                                        ResponseType = (TaskResponseType)requestResponse.ResponseType,
                                    };
                                break;
                            }
                        case TaskResponseType.TokenStoreItem:
                            {
                                taskResult = new EngineerTaskResult
                                {
                                    Id = taskid,
                                    EngineerId = requestResponse.EngineerId,
                                    Command = requestResponse.Command,
                                    UsersThatHaveReadResult = requestResponse.UsersThatHaveReadResult,
                                    ResultObject = requestResponse.Result.Deserialize<List<TokenStoreItem>>(),
                                    Status = (EngTaskStatus)requestResponse.Status,
                                    ResponseType = (TaskResponseType)requestResponse.ResponseType,
                                };
                                break;
                            }
                        default:
                            break;
                    }



                    if(!EngineerReturnedTaskIds.ContainsKey(engineerId))
                    {
                        EngineerReturnedTaskIds.Add(engineerId, new List<string>());
                    }
                    if (!EngineerReturnedTaskIds[engineerId].Contains(taskid))
                    {
                        EngineerReturnedTaskIds[engineerId].Add(taskid);
                        //if the task is a context changer we should update the implant note, and possibly the icon or username 
                        if (contextChangingCommands.Contains(taskResult.Command,StringComparer.CurrentCultureIgnoreCase))
                        {
                            if(taskResult.Status == EngTaskStatus.Complete)
                            {
                                //find the engineer object this task belongs to
                                Engineer engineer = null;
                                foreach (Engineer eng in Engineers.EngineerList)
                                {
                                    if (eng.Id == engineerId)
                                    {
                                        engineer = eng;
                                    }
                                }
                                if(engineer != null)
                                {
                                    if(taskResult.Command.Equals("rev2self",StringComparison.CurrentCultureIgnoreCase))
                                    {
                                        engineer.Note = "";
                                        engineer.Integrity = engineer.engineerMetadata.Integrity;
                                    }
                                    else if (taskResult.Command.Equals("getsystem", StringComparison.CurrentCultureIgnoreCase))
                                    {
                                        engineer.Note = "Context: NT AUTHORITY\\SYSTEM"; 
                                        engineer.Integrity = "SYSTEM";
                                    }
                                    else
                                    {
                                        engineer.Note = "Impersonating";
                                    }

                                }

                            }
                        }
                    }
                    if (!TaskStatusDic.ContainsKey(taskid))
                    {
                        TaskStatusDic.Add(taskid, requestResponse.Status);
                    }
                    else
                    {
                        TaskStatusDic[taskid] = requestResponse.Status;
                    }
                    if (OnStateChange is not null)
                    {
                        await OnStateChange();
                    }
                    //if inputDic shows command name is seatbelt call the ParseAndStoreCommandOutput if command status is complete
                    if (TaskInputDic.ContainsKey(taskid))
                    {
                        bool containsSeatbelt = TaskInputDic[taskid].Arguments.Values.Any(value => value.Contains("seatbelt"));
                        if (containsSeatbelt)
                        {
                            if (TaskStatusDic[taskid] == EngTaskStatus.Complete)
                            {
                                //call the ParseAndStoreCommandOutput method
                                //split on all the newline chars
                                string[] parseReult = taskResult.Result.ToString().Split(new[] { Environment.NewLine }, StringSplitOptions.None);
                                await ParseAndStoreCommandOutput(parseReult, "seatbelt", taskid, engineerId);
                            }
                        }
                    }
                    return taskResult;
                }
                return null;
            }
            return null;

        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
            Console.WriteLine(e.StackTrace);
            return null;
        }

    }

    public  async Task CancelTask(string taskid, string engineerid)
    {
        DialogOptions options = new DialogOptions() { CloseOnEscapeKey = true, MaxWidth = MaxWidth.Medium, FullWidth = true };

        var dialog = DialogService.Show<YesNoSimpleMudDialog>("Are you sure you want to cancel running task", options);
        //if the result is true then add the new profile to the list
        var result = await dialog.Result;

        if (!result.Cancelled)
        {
            string CancelTaskRequestNumber = await HardHatHubClient._hub.CancelRunningTask(taskid, engineerid);
            CancelTaskNumbersToWatch.Add(CancelTaskRequestNumber);
            Engineers.ShowInfoToast($"Request to cancel task {taskid} sent");
        }
        if (OnStateChange is not null)
        {
            await OnStateChange();
        }
    }

    public static async Task ParseAndStoreCommandOutput(string[] output, string CommandName,string taskid,string engineerID)
    {
        Dictionary<string, string> commandOutput = new Dictionary<string, string>();
        List<string> outputParse = new List<string>();
        foreach (string line in output)
        {
            outputParse.Add(line);
        }
        if (CommandName == "seatbelt")
        {
            commandOutput = HardHatC2Client.Utilities.CommandOutputParsing.ParseSeatbelt(outputParse);
        }
        if(commandOutput.Count > 0)
        {
            List<string> ParsedCommandOutput = new(); 
            //List<string> commandKeys = new();
            //take each key and value from the commandOutput and join them into a string seperatted by || then add that string to the ParsedCommandOutput list
            //get the engineer object with the matching id and return its hostname
            var engineer = Engineers.EngineerList.Where(s => s.Id == engineerID).FirstOrDefault();
            string hostname = engineer.Hostname;
            string username = engineer.Username;
            foreach(KeyValuePair<string,string> kvp in commandOutput)
            {
                ParsedCommandOutput.Add($"{kvp.Key}||{kvp.Value}");
                //commandKeys.Add(kvp.Key);
                //string entityName = ReconCenter.DetermineEntity(new Dictionary<string,string>{ { "Hostname", hostname },{ "Username", username } }, CommandName, kvp.Key);
                //await ReconCenter.AddAutoParsedCommandEntry(entityName, kvp.Key,kvp.Value,CommandName,hostname);
            }
            ParsedCommandOutputDic.Add(taskid, ParsedCommandOutput);
        }
    }

    private async Task OnShowCommandHistory(KeyboardEventArgs e)
    {
        if (PreviousCommands.Count > 0)
        {
            //check to make sure the key pressed was the up arrow
            if (e.Code == "ArrowUp")
            {
                HistoryIndex++;
                if (HistoryIndex > (PreviousCommands.Count-1))
                {
                    HistoryIndex = (PreviousCommands.Count - 1);
                }
                //get the Historyindex, set placeholder text to the history item at that index, and increment the index
                if (HistoryIndex <= PreviousCommands.Count)
                {
                    if (HistoryIndex < 0)
                    {
                        HistoryIndex = 0;
                    }
                    //Task.Run(async () => await GetCommandHistory());
                    await GetCommandHistory();
                }
            }
            else if (e.Code == "ArrowDown")
            {
                HistoryIndex--;
                if (HistoryIndex < -1)
                {
                    //if index is less than -1 set it to -1 and update the placeholder text to be blank
                    HistoryIndex = -1;
                    TextSuppersion = false; //allows text box to be updated
                    placeHolder = "";
                    await Task.Delay(500);
                    TextSuppersion = true; // reset so textbox can be typed in without autoclearing until submission 
                }
                //get the Historyindex, set placeholder text to the history item at that index, and decrement the index
                if (HistoryIndex >= 0)
                {
                    //Task.Run(async () => await GetCommandHistory());
                    await GetCommandHistory();
                }
            }
        }
        if (OnStateChange is not null)
        {
            await OnStateChange();
        }
    }

    private async Task GetCommandHistory()
    {
        TextSuppersion = false; //allows text box to be updated
        placeHolder = PreviousCommands[HistoryIndex];
        await Task.Delay(500);
        TextSuppersion = true; // reset so textbox can be typed in without autoclearing until submission
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (FirstRender)
        {
            RestClientOptions options = new RestClientOptions();
            options.BaseUrl = restClient.Options.BaseUrl;
            options.RemoteCertificateValidationCallback = restClient.Options.RemoteCertificateValidationCallback;
            string jwtToken = await LocalStorage.GetItemAsync<string>("bearerToken");
            options.Authenticator = new JwtAuthenticator(jwtToken);
            _restClient = new RestClient(options);
            foreach (KeyValuePair<string, List<string>> kvp in EngineerOutboundTaskIds)
            {
                UpdateTaskResponse(kvp.Key, kvp.Value);
            }
            FirstRender = false;
            Login.isVisible = false;
            if (Login.SignedInUser.Equals("hardhat_admin",StringComparison.CurrentCultureIgnoreCase))
            {
                Nav.NavigateTo("Settings");
            }
            else
            {
                Nav.NavigateTo("Index");
            }
        }
        else
        {

            if (interactedEngIdUpdated)
            {
                base.OnAfterRender(firstRender);
                engineer_tabs.ActivatePanel(interactedEngineerId);
                StateHasChanged();
            }
            if(engineer_tabs.ActivePanel != null && engineer_tabs.ActivePanel.ID == interactedEngineerId)
            {
                interactedEngIdUpdated = false;
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        OnStateChange = ImplementOnStateChangeEvent;
        _onWindowInteractSubmission = OnCommandSelectionEnterKeyDown;
        Nav = navigationManagerDefault;
        _dialogService = DialogService;

        //if (stopwatch.IsRunning == false)
        //{
        //    stopwatch.Start();
        //    Task.Run( async() =>
        //    {
        //        while (true)
        //        {
        //            if (stopwatch.ElapsedMilliseconds > 500)
        //            {
        //                await OnStateChange();
        //                stopwatch.Restart();
        //            }
        //            await Task.Delay(100);
        //        }
        //    });
        //}
    }
}
  
